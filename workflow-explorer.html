<!DOCTYPE html>
<!--
  WORKFLOW EXPLORER — Single-file interactive explorer for the 6-phase technical workflow system.

  Architecture:
    Inline CSS + JS. dagre.js CDN for auto-layout. marked.js CDN for markdown rendering.
    SVG canvas rendering. No build step, no framework — open directly in a browser.

  Data structures:
    FLOWCHARTS           — node/connection definitions per phase/skill/command (dagre-compatible: w/h, no x/y)
    OVERVIEW_NODES       — hand-positioned nodes for the top-level pipeline view
    OVERVIEW_CONNECTIONS — connections between overview nodes
    phases               — metadata per phase (color, cmd, label, complexity, etc.)
    FLOWCHART_DESCS      — rich descriptions shown in the info bar
    SKILL_NEXT_PHASE     — maps skill flowchart keys to their next workflow phase (label, target, color)
    SOURCE_MAP           — maps flowchart keys to repo-relative source file paths for markdown viewer

  Navigation model:
    Sidebar-driven. Two view functions + markdown viewer + info panel:
      showOverview()        — pipeline view (OVERVIEW_NODES)
      selectPhase(phase)    — flowchart view (FLOWCHARTS[phase])
      openInfoPanel()       — open info slide-over for current flowchart
      openMdViewer(key)     — open markdown viewer for a flowchart's source file

  Markdown viewer:
    Slide-over panel (65% width, 100% on mobile, z-index 30). Fetches .md files from GitHub raw URL,
    strips YAML frontmatter, renders via marked.parse(). Relative .md links are intercepted and
    navigated within the viewer. Breadcrumb trail with scroll position memory for back navigation.
    In-memory _mdCache for fetched content. Opened via "Source" button in info bar or </> in tooltip.

  Layout:
    CSS grid: 300px sidebar + flexible canvas area. Info panel slides over canvas (fixed positioned).
    Canvas takes full height. Sidebar fixed overlay with margin push.

  Rendering:
    renderSVG() draws all views into <svg id="svg-canvas">.
    computeFlowchartLayout(key) runs dagre and caches results in _layoutCache.
    Symmetric viewBox calculation: computes minX/minY/maxX/maxY from all nodes, applies equal padding.
    Zoom/pan via viewBox manipulation (wheel + drag + touch).

  Flowchart data:
    Manual JS objects — not generated. dagre handles positioning only.
    To modify a flowchart, update FLOWCHARTS[key].nodes and .connections.
    Node shapes: pill = start/end, diamond = decision, stop = hard-cornered terminal (STOP/BLOCK), rect = action step.
    Connection types map to colors + arrow markers (yes=green, no=red, transition=orange dashed, backloop=gray dashed).

  Diamond edge routing (IMPORTANT):
    Dagre calculates waypoints to route edges around obstacles. However, adding a `port` hint (e.g., port: 'lower-left')
    causes the rendering code to DISCARD dagre's waypoints and draw a straight line instead (see hasPortHint check in renderSVG).
    This is intentional for simple direct edges but breaks edges that need to route around intermediate nodes.

    Rules:
    - Do NOT add `port` hints to edges that need to route around obstacles (e.g., "no" paths that skip multiple nodes)
    - The automatic port assignment in computeDiamondPorts() distributes edges based on target node x-positions (left-to-right)
    - `type: 'backloop'` edges are exempt — they always keep dagre's waypoints regardless of port hints
    - Use `weight: 2` on the main flow path to influence dagre's node placement (heavier = more direct routing)

  Node color system (type-based, not phase-based — CSS vars in :root):
    - var(--action)    sky blue    — primary work steps (validate, extract, etc.)
    - var(--agent)     cyan        — agent invocation nodes (with optional skillLink to agent flowchart)
    - var(--text-dim)  gray        — utility/support steps (read existing, load format, etc.)
    - var(--ask)       purple      — user interaction nodes
    - var(--routing)   amber       — non-blocking decision diamonds
    - var(--gate)      red         — STOP/BLOCK nodes (hard-cornered rects), refresh-cache
    - var(--discovery) green       — discovery script execution
    - var(--skill)     orange      — skill invocation nodes (rect, with skillLink)
    - var(--next)      blue        — next-phase navigation nodes (rect, command color, same shape as agent nodes)
    - var(--accent)    blue        — entry points, migrations, git commits
    - var(--{phase})   phase color — output artifact pills only (keeps phase identity)

  Conventions:
    - Clicking flowchart nodes with `desc` shows a tooltip; nodes with `skillLink` show tooltip first with a navigation link.
    - Overview nodes with `phase` are clickable and route to selectPhase().
    - The info panel (ⓘ button) shows contextual info for the current flowchart.
    - Skill flowcharts (except skill-review) have a `next` rect node at the end, command blue (var(--next)),
      connected from `end` via `type: 'transition'`, using `skillLink` for navigation. Badges (AGT/SKL/CMD) auto-render.
    - SOURCE_MAP must be updated when source files are renamed or added.

  Key sections (search terms):
    CSS:         "/* Info panel */"  "/* Markdown viewer */"
    Data:        "const FLOWCHARTS"  "const SOURCE_MAP"  "const SKILL_NEXT_PHASE"  "const FLOWCHART_DESCS"
    Rendering:   "function renderSVG"  "function computeFlowchartLayout"
    Interaction: "function showFcTooltip"  "function openInfoPanel"  "function openMdViewer"
-->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claude Technical Workflows Explorer</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242836;
    --border: #2e3345;
    --text: #e1e4ed;
    --text-dim: #8b90a0;
    --accent: #6c8aff;
    /* Phase colors */
    --research: #a78bfa;
    --discussion: #60a5fa;
    --specification: #34d399;
    --planning: #fbbf24;
    --implementation: #f97316;
    --review: #f472b6;
    /* Softer fills */
    --research-bg: rgba(167,139,250,0.12);
    --discussion-bg: rgba(96,165,250,0.12);
    --specification-bg: rgba(52,211,153,0.12);
    --planning-bg: rgba(251,191,36,0.12);
    --implementation-bg: rgba(249,115,22,0.12);
    --review-bg: rgba(244,114,182,0.12);
    /* Node type colors */
    --action: #38bdf8;
    --action-bg: rgba(56,189,248,0.12);
    --ask: #a78bfa;
    --ask-bg: rgba(167,139,250,0.15);
    --routing: #fbbf24;
    --routing-bg: rgba(251,191,36,0.15);
    --gate: #f43f5e;
    --gate-bg: rgba(244,63,94,0.15);
    --discovery: #34d399;
    --discovery-bg: rgba(52,211,153,0.15);
    --skill: #f97316;
    --skill-bg: rgba(249,115,22,0.15);
    --next: #6c8aff;
    --next-bg: rgba(108,138,255,0.15);
    --agent: #22d3ee;
    --agent-bg: rgba(34,211,238,0.15);
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
  }
  .layout {
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr;
    height: 100vh;
  }
  /* Sidebar — fixed overlay, pushes content via margin */
  .sidebar {
    position: fixed;
    top: 0; left: 0; bottom: 0;
    width: 300px;
    z-index: 40;
    background: var(--surface);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;
    touch-action: pan-y;
    padding: 16px;
    transform: translateX(0);
    transition: transform 0.2s ease;
  }
  .sidebar h1 {
    font-size: 15px;
    font-weight: 700;
    margin-bottom: 4px;
    color: var(--text);
  }
  .sidebar .subtitle {
    font-size: 11px;
    color: var(--text-dim);
    margin-bottom: 16px;
  }
  .sidebar { scrollbar-width: none; }
  .sidebar::-webkit-scrollbar { display: none; }
  .section-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    color: var(--text-dim);
    margin: 16px 0 8px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .section-label.collapsible { cursor: pointer; user-select: none; }
  .section-label.collapsible:hover { color: var(--text); }
  .section-label .chevron { font-size: 8px; transition: transform 0.15s; display: inline-block; }
  .section-label.collapsed .chevron { transform: rotate(-90deg); }
  .collapsible-content { overflow: hidden; }
  .collapsible-content.collapsed { display: none; }

  /* Timeline pipeline */
  .tl-wrapper { position: relative; padding-left: 24px; }
  .tl-group { position: relative; margin-bottom: 2px; }
  .tl-group:not(:last-child)::after {
    content: ''; position: absolute; left: -16px; top: 14px; bottom: -3px;
    width: 2px; background: var(--border); z-index: 0;
  }
  .tl-group:not(:first-child)::before {
    content: ''; position: absolute; left: -16px; top: -1px; height: 17px;
    width: 2px; background: var(--border); z-index: 0;
  }
  .tl-dot {
    position: absolute; left: -21px; top: 9px;
    width: 12px; height: 12px; border-radius: 50%;
    border: 2px solid var(--surface); z-index: 1;
  }
  .tl-cmd {
    display: flex; align-items: center; gap: 10px; width: 100%;
    padding: 8px 10px; border: 1px solid var(--border); border-radius: 6px;
    background: var(--surface2); color: var(--text); cursor: pointer;
    font-size: 13px; transition: all 0.15s; text-align: left; margin-bottom: 2px;
  }
  .tl-cmd:hover { border-color: var(--accent); }
  .tl-cmd.active { border-color: var(--accent); background: rgba(108,138,255,0.1); }
  .tl-cmd .name { font-weight: 600; font-size: 12px; flex: 1; }
  .tl-skill {
    display: flex; align-items: center; gap: 6px;
    width: calc(100% - 16px); margin-left: 16px;
    padding: 5px 8px; border: 1px solid var(--border); border-radius: 5px;
    background: transparent; color: var(--text-dim); cursor: pointer;
    font-size: 11px; font-family: monospace; margin-bottom: 4px; margin-top: 1px;
    transition: all 0.15s; text-align: left; position: relative;
  }
  .tl-skill:hover { border-color: var(--accent); color: var(--text); background: var(--surface2); }
  .tl-skill.active { border-color: var(--accent); color: var(--text); background: rgba(108,138,255,0.1); }
  .tl-skill::before {
    content: ''; position: absolute; left: -10px; top: 50%;
    width: 7px; height: 1px; background: var(--border);
  }
  .tl-skill::after {
    content: ''; position: absolute; left: -10px; top: -3px;
    width: 1px; height: calc(50% + 3px); background: var(--border);
  }
  .tl-skill .skill-label { flex: 1; }

  /* Badges */
  .badge {
    font-size: 8px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.5px; padding: 2px 5px; border-radius: 3px; flex-shrink: 0;
    font-family: -apple-system, system-ui, sans-serif;
  }
  .badge-cmd { background: rgba(108,138,255,0.15); color: var(--accent); }
  .badge-skl { background: rgba(249,115,22,0.15); color: #f97316; }
  .badge-agt { background: rgba(34,211,238,0.15); color: #22d3ee; }

  /* Dropdown items */
  .dropdown-btn {
    display: flex; align-items: center; gap: 8px; width: 100%;
    padding: 7px 10px; border: 1px solid var(--border); border-radius: 6px;
    background: var(--surface2); color: var(--text); cursor: pointer;
    font-size: 12px; margin-bottom: 4px; text-align: left;
    transition: all 0.15s; font-family: monospace;
  }
  .dropdown-btn:hover { border-color: var(--accent); }
  .dropdown-btn.active { border-color: var(--accent); background: rgba(108,138,255,0.1); }
  .dropdown-btn .btn-label { flex: 1; }
  .dropdown-subheading {
    font-size: 9px; text-transform: uppercase; letter-spacing: 1px;
    color: var(--text-dim); margin: 10px 0 6px; font-weight: 600; opacity: 0.7;
  }
  .dropdown-subheading:first-child { margin-top: 4px; }

  /* Sidebar footer */
  .sidebar-footer {
    position: sticky; bottom: -16px;
    margin: 20px -16px -16px; padding: 10px 16px 14px;
    border-top: 1px solid var(--border); background: var(--surface);
    text-align: center; font-size: 11px; color: var(--text-dim);
    line-height: 1.6; z-index: 2;
  }
  .sidebar-footer a { color: var(--text-dim); text-decoration: none; transition: color 0.15s; }
  .sidebar-footer a:hover { color: var(--accent); }
  .sidebar-footer .repo-link { display: inline-flex; align-items: center; gap: 5px; font-size: 11px; margin-bottom: 4px; }
  .sidebar-footer .credit { font-size: 10px; opacity: 0.7; }

  /* Legend */
  .legend { margin-top: 16px; }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 11px;
    color: var(--text-dim);
    margin-bottom: 4px;
  }
  .legend-icon {
    width: 28px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .legend-line {
    width: 28px; height: 3px; border-radius: 2px;
  }
  .legend-line.dashed { background: repeating-linear-gradient(90deg, var(--accent) 0 6px, transparent 6px 10px); }
  .legend-shape {
    width: 14px; height: 14px; border-radius: 3px; border: 1px solid;
  }
  .legend-shape-diamond {
    width: 12px; height: 12px; border: 1px solid;
    transform: rotate(45deg);
  }
  .legend-shape-pill {
    width: 24px; height: 12px; border-radius: 6px; border: 1px solid;
  }
  .nav-btn.dimmed {
    opacity: 0.35;
    pointer-events: none;
  }

  /* Sidebar toggle */
  .sidebar-toggle {
    position: absolute;
    top: 12px; left: 12px;
    z-index: 15;
    width: 28px; height: 28px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    transition: border-color 0.15s;
  }
  .sidebar-toggle:hover { border-color: var(--accent); }

  /* Sidebar collapse — fixed sidebar + margin push on content */
  .layout .canvas-area {
    margin-left: 300px;
    transition: margin-left 0.2s ease;
  }
  .layout.sidebar-collapsed .sidebar {
    transform: translateX(-300px);
  }
  .layout.sidebar-collapsed .canvas-area {
    margin-left: 0;
  }

  /* Sidebar backdrop (mobile overlay) */
  .sidebar-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 38;
  }
  .sidebar-backdrop.visible {
    display: block;
  }

  /* Mobile — pure overlay, no margin push */
  @media (max-width: 768px) {
    .layout .canvas-area {
      margin-left: 0;
    }
  }

  /* Main canvas */
  .canvas-area {
    position: relative;
    overflow: hidden;
    background: var(--bg);
    touch-action: none;
  }
  .canvas-area svg {
    width: 100%;
    height: 100%;
  }




  /* Zoom controls */
  .zoom-controls {
    position: absolute;
    bottom: 12px; left: 12px;
    display: flex;
    gap: 4px;
    z-index: 5;
  }
  .zoom-btn {
    width: 32px; height: 32px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
  }
  .zoom-btn:hover { border-color: var(--accent); }
  .zoom-btn-context { margin-left: 4px; }
  .zoom-btn-context.disabled { opacity: 0.3; pointer-events: none; }
  @media (max-width: 768px) {
    .zoom-btn { width: 44px; height: 44px; font-size: 20px; }
    .zoom-controls { gap: 6px; }
    .sidebar-toggle { width: 44px; height: 44px; }
  }

  /* Overview nav button */
  .nav-overview {
    display: block;
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
    font-size: 12px;
    margin-bottom: 16px;
    transition: all 0.15s;
    text-align: left;
  }
  .nav-overview:hover { border-color: var(--accent); }
  .nav-overview.active { border-color: var(--accent); background: rgba(108,138,255,0.1); }

  /* Tooltip */
  .tooltip {
    position: absolute;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 12px;
    color: var(--text);
    pointer-events: none;
    z-index: 20;
    max-width: 260px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    opacity: 0;
    transition: opacity 0.15s;
  }
  .tooltip.show { opacity: 1; }

  /* Flowchart node tooltip (click-to-describe) */
  #fc-tooltip {
    position: absolute;
    display: none;
    background: var(--surface);
    border: 2px solid var(--border);
    border-radius: 8px;
    padding: 12px 16px;
    max-width: 320px;
    z-index: 25;
    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    pointer-events: auto;
  }
  #fc-tooltip-title {
    font-size: 13px;
    font-weight: 700;
    margin-bottom: 6px;
    color: var(--text);
  }
  #fc-tooltip-desc {
    font-size: 12px;
    line-height: 1.5;
    color: var(--text-dim);
  }

  /* Info panel slide-over */
  .info-panel-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.2);
    z-index: 29;
  }
  .info-panel-backdrop.visible { display: block; }
  .info-panel {
    position: fixed;
    top: 0; right: 0;
    width: 420px;
    height: 100vh;
    background: var(--surface);
    border-left: 1px solid var(--border);
    transform: translateX(100%);
    transition: transform 0.2s ease;
    z-index: 30;
    display: flex;
    flex-direction: column;
    touch-action: pan-y;
    overscroll-behavior: contain;
  }
  .info-panel.open { transform: translateX(0); }
  .info-panel-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .info-panel-title {
    flex: 1;
    font-size: 14px;
    font-weight: 700;
    color: var(--text);
  }
  .info-panel-close {
    background: none; border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 18px;
    padding: 4px 8px;
    flex-shrink: 0;
  }
  .info-panel-close:hover { color: var(--text); }
  .info-panel-body {
    flex: 1;
    overflow-y: auto;
    padding: 20px 24px 40px;
  }
  .info-panel-body .info-subtitle {
    font-size: 11px;
    color: var(--text-dim);
    font-family: 'SF Mono', 'Fira Code', monospace;
    margin-bottom: 14px;
  }
  .info-panel-body .info-summary {
    font-size: 13px;
    font-weight: 600;
    color: var(--text);
    line-height: 1.6;
    margin-bottom: 12px;
  }
  .info-panel-body .info-desc {
    font-size: 12.5px;
    color: var(--text-dim);
    line-height: 1.6;
  }
  .info-panel-body .info-desc p {
    margin-bottom: 8px;
  }
  .info-panel-body .info-desc strong {
    color: var(--text);
    font-weight: 600;
  }
  .info-panel-body .info-desc code {
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 11px;
    background: var(--surface2);
    padding: 1px 5px;
    border-radius: 3px;
    color: var(--accent);
  }
  .info-panel-body .info-meta {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-top: 14px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
    font-size: 11px;
    color: var(--text-dim);
  }
  .info-panel-body .info-meta span {
    white-space: nowrap;
  }
  .info-panel-body .info-meta strong {
    color: var(--text);
    font-weight: 600;
  }
  .info-panel-source-btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-top: 16px;
    padding: 6px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text-dim);
    cursor: pointer;
    font-size: 12px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    transition: all 0.15s;
  }
  .info-panel-source-btn:hover { border-color: var(--accent); color: var(--text); }
  @media (max-width: 768px) {
    .info-panel { width: 100%; }
  }

  /* Markdown viewer slide-over */
  .md-viewer-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.3);
    z-index: 34;
  }
  .md-viewer-backdrop.visible { display: block; }
  .md-viewer {
    position: fixed;
    top: 0; right: 0;
    width: 65%;
    height: 100vh;
    background: var(--surface);
    border-left: 1px solid var(--border);
    transform: translateX(100%);
    transition: transform 0.2s ease;
    z-index: 35;
    display: flex;
    flex-direction: column;
    touch-action: pan-y;
    overscroll-behavior: contain;
  }
  .md-viewer.open { transform: translateX(0); }
  .md-viewer-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .md-viewer-back {
    background: none; border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 16px;
    padding: 4px 8px;
    border-radius: 4px;
  }
  .md-viewer-back:hover { color: var(--text); background: var(--surface2); }
  .md-viewer-back:disabled { opacity: 0.3; pointer-events: none; }
  .md-viewer-breadcrumb {
    flex: 1;
    font-size: 12px;
    color: var(--text-dim);
    font-family: 'SF Mono', 'Fira Code', monospace;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .md-viewer-breadcrumb span {
    cursor: pointer;
    color: var(--accent);
  }
  .md-viewer-breadcrumb span:hover { text-decoration: underline; }
  .md-viewer-breadcrumb span.current {
    color: var(--text);
    cursor: default;
  }
  .md-viewer-breadcrumb span.current:hover { text-decoration: none; }
  .md-viewer-github {
    flex-shrink: 0;
    background: none;
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 11px;
    padding: 3px 8px;
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: 4px;
    transition: color 0.15s, border-color 0.15s;
  }
  .md-viewer-github:hover { color: var(--text); border-color: var(--text-dim); }
  .md-viewer-close {
    background: none; border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 18px;
    padding: 4px 8px;
    flex-shrink: 0;
  }
  .md-viewer-close:hover { color: var(--text); }
  .md-viewer-body {
    flex: 1;
    overflow-y: auto;
    padding: 20px 24px 40px;
  }
  .md-viewer-body > :first-child { margin-top: 0; }
  .md-viewer-body h1 { font-size: 20px; font-weight: 700; color: var(--text); margin: 24px 0 12px; }
  .md-viewer-body h2 { font-size: 16px; font-weight: 700; color: var(--text); margin: 20px 0 10px; }
  .md-viewer-body h3 { font-size: 14px; font-weight: 600; color: var(--text); margin: 16px 0 8px; }
  .md-viewer-body h4 { font-size: 13px; font-weight: 600; color: var(--text-dim); margin: 12px 0 6px; }
  .md-viewer-body p { font-size: 13px; line-height: 1.7; color: var(--text-dim); margin-bottom: 10px; }
  .md-viewer-body ul, .md-viewer-body ol { font-size: 13px; line-height: 1.7; color: var(--text-dim); padding-left: 20px; margin-bottom: 10px; }
  .md-viewer-body li { margin-bottom: 4px; }
  .md-viewer-body code {
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 12px;
    background: var(--surface2);
    padding: 1px 5px;
    border-radius: 3px;
    color: var(--accent);
  }
  .md-viewer-body pre {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 12px 16px;
    overflow-x: auto;
    margin-bottom: 12px;
  }
  .md-viewer-body pre code { background: none; padding: 0; color: var(--text); }
  .md-viewer-body blockquote {
    border-left: 3px solid var(--accent);
    padding-left: 12px;
    margin: 10px 0;
    color: var(--text-dim);
    font-style: italic;
  }
  .md-viewer-body a { color: var(--accent); text-decoration: none; }
  .md-viewer-body a:hover { text-decoration: underline; }
  .md-viewer-body table { border-collapse: collapse; width: 100%; margin-bottom: 12px; font-size: 12px; }
  .md-viewer-body th { text-align: left; padding: 6px 8px; background: var(--surface2); color: var(--text-dim); border-bottom: 1px solid var(--border); }
  .md-viewer-body td { padding: 6px 8px; border-bottom: 1px solid var(--border); color: var(--text); }
  .md-viewer-body hr { border: none; border-top: 1px solid var(--border); margin: 16px 0; }
  .md-viewer-body strong { color: var(--text); }
  .md-viewer-loading { text-align: center; padding: 40px; color: var(--text-dim); font-size: 13px; }
  .md-viewer-error { text-align: center; padding: 40px; color: #f43f5e; font-size: 13px; }
  @media (max-width: 768px) {
    .md-viewer { width: 100%; }
  }

  /* Source button in tooltip */
  .fc-tooltip-source {
    position: absolute;
    top: 8px; right: 8px;
    background: none; border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 10px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    padding: 2px 6px;
    display: none;
  }
  .fc-tooltip-source:hover { border-color: var(--accent); color: var(--text); }
  .fc-tooltip-link {
    display: none;
    margin-top: 8px;
    font-size: 11px;
    font-weight: 600;
    color: var(--accent);
    cursor: pointer;
    text-decoration: none;
    opacity: 0.85;
  }
  .fc-tooltip-link:hover { opacity: 1; text-decoration: underline; }

  /* ── Overview page (HTML, replaces SVG overview) ── */
  .overview-page { display: none; }
  .canvas-area.overview-active { overflow-y: auto; touch-action: auto; }
  .canvas-area.overview-active #svg-canvas { display: none; }
  .canvas-area.overview-active .zoom-controls { display: none; }
  .canvas-area.overview-active .overview-page { display: flex; }

  .overview-page {
    flex-direction: column;
    align-items: center;
    padding: 72px 20px 80px;
    line-height: 1.6;
    min-height: 100%;
  }

  .overview-page .ov-hero {
    max-width: 660px;
    text-align: center;
    margin-bottom: 56px;
  }
  .overview-page .ov-hero h1 {
    font-size: 2.4rem;
    font-weight: 700;
    letter-spacing: -0.03em;
    margin-bottom: 18px;
    color: var(--text);
  }
  .overview-page .ov-hero .ov-overview {
    font-size: 1rem;
    color: var(--text-dim);
    line-height: 1.75;
    margin-bottom: 24px;
  }
  .overview-page .ov-hint {
    display: inline-block;
    font-size: 0.84rem;
    color: var(--text-dim);
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 20px;
  }
  .overview-page .ov-hint code {
    color: var(--accent);
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    font-size: 0.82rem;
  }

  .ov-grid { position: relative; }
  .ov-row {
    display: flex;
    align-items: stretch;
    gap: 0;
  }
  .ov-arrow-h {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 48px;
    flex-shrink: 0;
  }
  .ov-arrow-h svg { overflow: visible; }

  /* Phase cards */
  .ov-card {
    position: relative;
    width: 240px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-top-width: 3px;
    border-radius: 10px;
    padding: 20px 18px 16px;
    cursor: pointer;
    overflow: hidden;
    transition: border-color 0.25s, box-shadow 0.25s, transform 0.18s;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
  }
  .ov-card[data-phase="research"]       { border-top-color: var(--research); }
  .ov-card[data-phase="discussion"]      { border-top-color: var(--discussion); }
  .ov-card[data-phase="specification"]   { border-top-color: var(--specification); }
  .ov-card[data-phase="planning"]        { border-top-color: var(--planning); }
  .ov-card[data-phase="implementation"]  { border-top-color: var(--implementation); }
  .ov-card[data-phase="review"]          { border-top-color: var(--review); }

  .ov-card[data-phase="research"]:hover       { border-color: var(--research);       box-shadow: 0 0 24px -4px rgba(167,139,250,0.25); transform: translateY(-2px); }
  .ov-card[data-phase="discussion"]:hover      { border-color: var(--discussion);      box-shadow: 0 0 24px -4px rgba(96,165,250,0.25);  transform: translateY(-2px); }
  .ov-card[data-phase="specification"]:hover   { border-color: var(--specification);   box-shadow: 0 0 24px -4px rgba(52,211,153,0.25);  transform: translateY(-2px); }
  .ov-card[data-phase="planning"]:hover        { border-color: var(--planning);        box-shadow: 0 0 24px -4px rgba(251,191,36,0.25);  transform: translateY(-2px); }
  .ov-card[data-phase="implementation"]:hover  { border-color: var(--implementation);  box-shadow: 0 0 24px -4px rgba(249,115,22,0.25);  transform: translateY(-2px); }
  .ov-card[data-phase="review"]:hover          { border-color: var(--review);          box-shadow: 0 0 24px -4px rgba(244,114,182,0.25); transform: translateY(-2px); }

  .ov-card .ov-watermark {
    position: absolute;
    top: 6px; right: 12px;
    font-size: 64px; font-weight: 800;
    color: var(--surface2);
    line-height: 1;
    pointer-events: none; user-select: none;
  }
  .ov-card .ov-phase-name {
    font-size: 15px; font-weight: 650;
    color: var(--text);
    margin-bottom: 8px;
    position: relative; z-index: 1;
  }
  .ov-card .ov-phase-desc {
    font-size: 11.5px; line-height: 1.55;
    color: var(--text-dim);
    position: relative; z-index: 1;
    flex: 1;
  }

  /* Badges */
  .ov-badges {
    display: flex; flex-wrap: wrap; gap: 6px;
    margin-top: 12px;
    position: relative; z-index: 1;
  }
  .ov-badge {
    display: inline-flex; align-items: center;
    font-size: 10px;
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    padding: 3px 8px;
    border-radius: 5px;
    white-space: nowrap;
    line-height: 1.3;
    border: 1px solid transparent;
    transition: background 0.15s, border-color 0.15s, color 0.15s;
  }
  .ov-badge-label {
    color: var(--text-dim);
    margin-right: 4px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    opacity: 0.7;
  }
  .ov-badge-command {
    color: var(--accent);
    background: rgba(108, 138, 255, 0.1);
  }
  .ov-badge-command.ov-badge-link {
    cursor: pointer;
  }
  .ov-badge-command.ov-badge-link:hover {
    background: rgba(108, 138, 255, 0.2);
    border-color: rgba(108, 138, 255, 0.3);
  }
  .ov-badge-skill {
    color: var(--implementation);
    background: rgba(249, 115, 22, 0.1);
  }
  .ov-badge-skill.ov-badge-link {
    cursor: pointer;
  }
  .ov-badge-skill.ov-badge-link:hover {
    background: rgba(249, 115, 22, 0.2);
    border-color: rgba(249, 115, 22, 0.3);
  }
  .ov-badge-output {
    color: var(--specification);
    background: rgba(52, 211, 153, 0.1);
  }

  /* Wrap connector */
  .ov-connector-row {
    width: 100%; height: 56px;
    display: flex; align-items: center; justify-content: center;
    position: relative;
  }
  .ov-connector-row svg {
    position: absolute; top: 0;
    left: 50%; transform: translateX(-50%);
  }

  /* Shortcut pill */
  .ov-shortcut-area {
    position: relative;
    width: 100%; height: 48px;
    margin-bottom: 8px;
  }
  .ov-shortcut-anchor {
    position: absolute;
    left: 696px; transform: translateX(-50%);
    top: 0;
    display: flex; flex-direction: column; align-items: center;
  }
  .ov-shortcut-pill {
    display: flex; align-items: center; gap: 8px;
    background: var(--surface);
    border: 1px solid rgba(129,140,248,0.3);
    border-radius: 8px;
    padding: 7px 14px;
    cursor: pointer;
    transition: border-color 0.2s, box-shadow 0.2s, transform 0.15s;
    white-space: nowrap;
  }
  .ov-shortcut-pill:hover {
    border-color: rgba(129,140,248,0.6);
    box-shadow: 0 0 16px -4px rgba(129,140,248,0.2);
    transform: translateY(-1px);
  }
  .ov-shortcut-pill .ov-pill-cmd {
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    font-size: 12px; color: #818cf8; font-weight: 600;
  }
  .ov-shortcut-pill .ov-pill-desc {
    font-size: 11px; color: var(--text-dim); opacity: 0.7;
  }
  .ov-shortcut-arrow {
    width: 1.5px; height: 12px;
    margin-top: 4px;
    background: repeating-linear-gradient(to bottom, rgba(129,140,248,0.5) 0 3px, transparent 3px 5px);
    position: relative;
    flex-shrink: 0;
  }
  .ov-shortcut-arrow::after {
    content: '';
    position: absolute;
    bottom: -5px; left: 50%;
    transform: translateX(-50%);
    width: 0; height: 0;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 5px solid rgba(129,140,248,0.5);
  }

  /* ── Overview responsive — stack cards vertically on medium/small screens ── */
  @media (max-width: 1100px) {
    .overview-page { padding: 48px 16px 60px; }
    .overview-page .ov-hero { margin-bottom: 36px; }
    .overview-page .ov-hero h1 { font-size: 1.8rem; }

    .ov-shortcut-area {
      position: static;
      height: auto;
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .ov-shortcut-anchor {
      position: static;
      transform: none;
    }
    .ov-shortcut-arrow { display: none; }

    .ov-row {
      flex-direction: column;
      align-items: center;
      gap: 14px;
    }
    .ov-arrow-h { display: none; }
    .ov-connector-row { display: none; }
    .ov-card {
      width: 100%;
      max-width: 400px;
    }
    .ov-grid > .ov-row + .ov-row {
      margin-top: 14px;
    }
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/@dagrejs/dagre@1.1.4/dist/dagre.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked@15.0.6/marked.min.js"></script>
</head>
<body>

<div class="layout">
  <!-- Sidebar -->
  <div class="sidebar">
    <h1>Technical Workflows</h1>
    <div class="subtitle">Interactive architecture explorer</div>

    <button class="nav-overview active nav-btn" onclick="showOverview()" id="btn-overview">Overview</button>

    <div class="section-label collapsible" onclick="toggleSidebarSection(this)"><span class="chevron">▼</span> Workflow Pipeline</div>
    <div class="collapsible-content">
      <div class="tl-wrapper">
        <div class="tl-group"><div class="tl-dot" style="background:var(--research)"></div>
          <button class="nav-btn tl-cmd" onclick="selectPhase('research',this)" id="btn-research"><span class="name">1. Research</span><span class="badge badge-cmd">cmd</span></button>
          <button class="nav-btn tl-skill" onclick="selectPhase('skill-research',this)" id="btn-skill-research"><span class="skill-label">technical-research</span><span class="badge badge-skl">skl</span></button>
        </div>
        <div class="tl-group"><div class="tl-dot" style="background:var(--discussion)"></div>
          <button class="nav-btn tl-cmd" onclick="selectPhase('discussion',this)" id="btn-discussion"><span class="name">2. Discussion</span><span class="badge badge-cmd">cmd</span></button>
          <button class="nav-btn tl-skill" onclick="selectPhase('skill-discussion',this)" id="btn-skill-discussion"><span class="skill-label">technical-discussion</span><span class="badge badge-skl">skl</span></button>
        </div>
        <div class="tl-group"><div class="tl-dot" style="background:var(--specification)"></div>
          <button class="nav-btn tl-cmd" onclick="selectPhase('specification',this)" id="btn-specification"><span class="name">3. Specification</span><span class="badge badge-cmd">cmd</span></button>
          <button class="nav-btn tl-skill" onclick="selectPhase('skill-specification',this)" id="btn-skill-specification"><span class="skill-label">technical-specification</span><span class="badge badge-skl">skl</span></button>
        </div>
        <div class="tl-group"><div class="tl-dot" style="background:var(--planning)"></div>
          <button class="nav-btn tl-cmd" onclick="selectPhase('planning',this)" id="btn-planning"><span class="name">4. Planning</span><span class="badge badge-cmd">cmd</span></button>
          <button class="nav-btn tl-skill" onclick="selectPhase('skill-planning',this)" id="btn-skill-planning"><span class="skill-label">technical-planning</span><span class="badge badge-skl">skl</span></button>
        </div>
        <div class="tl-group"><div class="tl-dot" style="background:var(--implementation)"></div>
          <button class="nav-btn tl-cmd" onclick="selectPhase('implementation',this)" id="btn-implementation"><span class="name">5. Implementation</span><span class="badge badge-cmd">cmd</span></button>
          <button class="nav-btn tl-skill" onclick="selectPhase('skill-implementation',this)" id="btn-skill-implementation"><span class="skill-label">technical-implementation</span><span class="badge badge-skl">skl</span></button>
        </div>
        <div class="tl-group"><div class="tl-dot" style="background:var(--review)"></div>
          <button class="nav-btn tl-cmd" onclick="selectPhase('review',this)" id="btn-review"><span class="name">6. Review</span><span class="badge badge-cmd">cmd</span></button>
          <button class="nav-btn tl-skill" onclick="selectPhase('skill-review',this)" id="btn-skill-review"><span class="skill-label">technical-review</span><span class="badge badge-skl">skl</span></button>
        </div>
      </div>
    </div>

    <div class="section-label collapsible" onclick="toggleSidebarSection(this)"><span class="chevron">▼</span> Skills</div>
    <div class="collapsible-content">
      <div class="dropdown-subheading">Workflow Commands</div>
      <button class="nav-btn dropdown-btn" data-phase="research" onclick="selectPhase('research',this)"><span class="badge badge-cmd">cmd</span><span class="btn-label">start-research</span></button>
      <button class="nav-btn dropdown-btn" data-phase="discussion" onclick="selectPhase('discussion',this)"><span class="badge badge-cmd">cmd</span><span class="btn-label">start-discussion</span></button>
      <button class="nav-btn dropdown-btn" data-phase="specification" onclick="selectPhase('specification',this)"><span class="badge badge-cmd">cmd</span><span class="btn-label">start-specification</span></button>
      <button class="nav-btn dropdown-btn" data-phase="planning" onclick="selectPhase('planning',this)"><span class="badge badge-cmd">cmd</span><span class="btn-label">start-planning</span></button>
      <button class="nav-btn dropdown-btn" data-phase="implementation" onclick="selectPhase('implementation',this)"><span class="badge badge-cmd">cmd</span><span class="btn-label">start-implementation</span></button>
      <button class="nav-btn dropdown-btn" data-phase="review" onclick="selectPhase('review',this)"><span class="badge badge-cmd">cmd</span><span class="btn-label">start-review</span></button>
      <div class="dropdown-subheading">Workflow Skills</div>
      <button class="nav-btn dropdown-btn" data-phase="skill-research" onclick="selectPhase('skill-research',this)"><span class="badge badge-skl">skl</span><span class="btn-label">technical-research</span></button>
      <button class="nav-btn dropdown-btn" data-phase="skill-discussion" onclick="selectPhase('skill-discussion',this)"><span class="badge badge-skl">skl</span><span class="btn-label">technical-discussion</span></button>
      <button class="nav-btn dropdown-btn" data-phase="skill-specification" onclick="selectPhase('skill-specification',this)"><span class="badge badge-skl">skl</span><span class="btn-label">technical-specification</span></button>
      <button class="nav-btn dropdown-btn" data-phase="skill-planning" onclick="selectPhase('skill-planning',this)"><span class="badge badge-skl">skl</span><span class="btn-label">technical-planning</span></button>
      <button class="nav-btn dropdown-btn" data-phase="skill-implementation" onclick="selectPhase('skill-implementation',this)"><span class="badge badge-skl">skl</span><span class="btn-label">technical-implementation</span></button>
      <button class="nav-btn dropdown-btn" data-phase="skill-review" onclick="selectPhase('skill-review',this)"><span class="badge badge-skl">skl</span><span class="btn-label">technical-review</span></button>
      <div class="dropdown-subheading">Standalone</div>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('start-feature',this)" id="btn-start-feature"><span class="badge badge-skl">skl</span><span class="btn-label">start-feature</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('link-deps',this)" id="btn-link-deps"><span class="badge badge-skl">skl</span><span class="btn-label">link-dependencies</span></button>
      <div class="dropdown-subheading">Utility</div>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('status',this)" id="btn-status"><span class="badge badge-skl">skl</span><span class="btn-label">status</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('view-plan',this)" id="btn-view-plan"><span class="badge badge-skl">skl</span><span class="btn-label">view-plan</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('migrate',this)" id="btn-migrate"><span class="badge badge-skl">skl</span><span class="btn-label">migrate</span></button>
    </div>

    <div class="section-label collapsible" onclick="toggleSidebarSection(this)"><span class="chevron">▼</span> Agents</div>
    <div class="collapsible-content">
      <div class="dropdown-subheading">Planning</div>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('planning-phase-designer',this)" id="btn-planning-phase-designer"><span class="badge badge-agt">agt</span><span class="btn-label">planning-phase-designer</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('planning-task-designer',this)" id="btn-planning-task-designer"><span class="badge badge-agt">agt</span><span class="btn-label">planning-task-designer</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('planning-task-author',this)" id="btn-planning-task-author"><span class="badge badge-agt">agt</span><span class="btn-label">planning-task-author</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('planning-dependency-grapher',this)" id="btn-planning-dependency-grapher"><span class="badge badge-agt">agt</span><span class="btn-label">planning-dependency-grapher</span></button>
      <div class="dropdown-subheading">Implementation</div>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('implementation-task-executor',this)" id="btn-implementation-task-executor"><span class="badge badge-agt">agt</span><span class="btn-label">implementation-task-executor</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('implementation-task-reviewer',this)" id="btn-implementation-task-reviewer"><span class="badge badge-agt">agt</span><span class="btn-label">implementation-task-reviewer</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('implementation-analysis-duplication',this)" id="btn-implementation-analysis-duplication"><span class="badge badge-agt">agt</span><span class="btn-label">analysis-duplication</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('implementation-analysis-standards',this)" id="btn-implementation-analysis-standards"><span class="badge badge-agt">agt</span><span class="btn-label">analysis-standards</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('implementation-analysis-architecture',this)" id="btn-implementation-analysis-architecture"><span class="badge badge-agt">agt</span><span class="btn-label">analysis-architecture</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('implementation-analysis-synthesizer',this)" id="btn-implementation-analysis-synthesizer"><span class="badge badge-agt">agt</span><span class="btn-label">analysis-synthesizer</span></button>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('implementation-analysis-task-writer',this)" id="btn-implementation-analysis-task-writer"><span class="badge badge-agt">agt</span><span class="btn-label">analysis-task-writer</span></button>
      <div class="dropdown-subheading">Review</div>
      <button class="nav-btn dropdown-btn" onclick="selectPhase('review-task-verifier',this)" id="btn-review-task-verifier"><span class="badge badge-agt">agt</span><span class="btn-label">review-task-verifier</span></button>
    </div>

    <div class="section-label collapsible" onclick="toggleSidebarSection(this)"><span class="chevron">▼</span> Legend</div>
    <div class="collapsible-content">
      <div class="legend legend-default" id="legend-default">
        <div class="legend-item"><div class="legend-icon"><div class="legend-line" style="background:var(--accent)"></div></div> Phase flow</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-line dashed" style="background:#818cf8"></div></div> Shortcut entry</div>
        <div class="legend-item" style="font-size:10px;color:var(--text-dim);margin-top:6px">Click any phase to view its flowchart</div>
      </div>
      <div class="legend legend-flowchart" id="legend-flowchart" style="display:none">
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape-pill" style="background:rgba(108,138,255,0.15);border-color:var(--accent)"></div></div> Start / End</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--action-bg);border-color:var(--action)"></div></div> Action step</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--surface2);border-color:var(--text-dim)"></div></div> Support / utility</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape-diamond" style="background:var(--routing-bg);border-color:var(--routing)"></div></div> Decision branch</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--gate-bg);border-color:var(--gate);border-radius:3px"></div></div> STOP / BLOCK</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--ask-bg);border-color:var(--ask)"></div></div> User interaction</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--discovery-bg);border-color:var(--discovery)"></div></div> Discovery script</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--skill-bg);border-color:var(--skill)"></div></div> Skill handoff</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--agent-bg);border-color:var(--agent)"></div></div> Agent invocation</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-shape" style="background:var(--next-bg);border-color:var(--next)"></div></div> Next command</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-line" style="background:#34d399"></div></div> Yes branch</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-line" style="background:#f43f5e"></div></div> No branch</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-line dashed" style="background:repeating-linear-gradient(90deg, #f97316 0 6px, transparent 6px 10px)"></div></div> Skill transition</div>
        <div class="legend-item"><div class="legend-icon"><div class="legend-line dashed" style="background:repeating-linear-gradient(90deg, #6b7280 0 6px, transparent 6px 10px)"></div></div> Back-loop</div>
      </div>
    </div>

    <div class="sidebar-footer">
      <a href="https://github.com/leeovery/claude-technical-workflows" target="_blank" rel="noopener" class="repo-link">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
        claude-technical-workflows
      </a>
      <div class="credit">Created with ❤️ by <a href="https://github.com/leeovery" target="_blank" rel="noopener">Lee Overy</a></div>
    </div>
  </div>

  <!-- Sidebar backdrop (mobile) -->
  <div class="sidebar-backdrop" id="sidebar-backdrop"></div>

  <!-- Canvas -->
  <div class="canvas-area" id="canvas-area">
    <button class="sidebar-toggle" id="sidebar-toggle" onclick="toggleSidebar()" title="Toggle sidebar"><svg style="width:12px;height:10px;flex-shrink:0" viewBox="0 0 12 10" fill="none"><rect y="0" width="12" height="1.5" rx="0.75" fill="currentColor"/><rect y="4.25" width="12" height="1.5" rx="0.75" fill="currentColor"/><rect y="8.5" width="12" height="1.5" rx="0.75" fill="currentColor"/></svg></button>

    <!-- Overview page (HTML, shown instead of SVG in overview mode) -->
    <div class="overview-page" id="overview-page">
      <section class="ov-hero">
        <h1>Technical Workflow System</h1>
        <p class="ov-overview">
          A structured pipeline for turning ideas into verified production code.
          Six phases guide you from early exploration through architecture decisions,
          validated specifications, implementation planning, test-driven development,
          and final review. Start anywhere &mdash; each phase builds on the artifacts of the previous.
        </p>
        <div class="ov-hint">
          Run <code>/start-research</code> to begin exploring, or <code>/start-feature</code> to jump straight to specification.
        </div>
      </section>

      <div class="ov-grid">
        <div class="ov-shortcut-area">
          <div class="ov-shortcut-anchor">
            <div class="ov-shortcut-pill" onclick="selectPhase('start-feature')">
              <span class="ov-pill-cmd">/start-feature</span>
              <span class="ov-pill-desc">skip to spec</span>
            </div>
            <div class="ov-shortcut-arrow"></div>
          </div>
        </div>

        <div class="ov-row">
          <div class="ov-card" data-phase="research" onclick="selectPhase('research')">
            <span class="ov-watermark">1</span>
            <div class="ov-phase-name">Research</div>
            <div class="ov-phase-desc">Explore ideas, feasibility, and validate concepts across technical and market domains</div>
            <div class="ov-badges">
              <span class="ov-badge ov-badge-command ov-badge-link" onclick="event.stopPropagation(); selectPhase('research')"><span class="ov-badge-label">cmd</span>/start-research</span>
              <span class="ov-badge ov-badge-skill ov-badge-link" onclick="event.stopPropagation(); selectPhase('skill-research')"><span class="ov-badge-label">skill</span>technical-research</span>
              <span class="ov-badge ov-badge-output"><span class="ov-badge-label">output</span>docs/workflow/research/</span>
            </div>
          </div>
          <div class="ov-arrow-h"><svg width="48" height="12" viewBox="0 0 48 12"><line x1="4" y1="6" x2="38" y2="6" stroke="#8b90a0" stroke-opacity="0.4" stroke-width="1.5" stroke-dasharray="4,3"/><polygon points="38,2 46,6 38,10" fill="#8b90a0" fill-opacity="0.4"/></svg></div>
          <div class="ov-card" data-phase="discussion" onclick="selectPhase('discussion')">
            <span class="ov-watermark">2</span>
            <div class="ov-phase-name">Discussion</div>
            <div class="ov-phase-desc">Capture architecture decisions, debates, edge cases, and their rationale</div>
            <div class="ov-badges">
              <span class="ov-badge ov-badge-command ov-badge-link" onclick="event.stopPropagation(); selectPhase('discussion')"><span class="ov-badge-label">cmd</span>/start-discussion</span>
              <span class="ov-badge ov-badge-skill ov-badge-link" onclick="event.stopPropagation(); selectPhase('skill-discussion')"><span class="ov-badge-label">skill</span>technical-discussion</span>
              <span class="ov-badge ov-badge-output"><span class="ov-badge-label">output</span>docs/workflow/discussion/</span>
            </div>
          </div>
          <div class="ov-arrow-h"><svg width="48" height="12" viewBox="0 0 48 12"><line x1="4" y1="6" x2="38" y2="6" stroke="#8b90a0" stroke-opacity="0.4" stroke-width="1.5" stroke-dasharray="4,3"/><polygon points="38,2 46,6 38,10" fill="#8b90a0" fill-opacity="0.4"/></svg></div>
          <div class="ov-card" data-phase="specification" onclick="selectPhase('specification')">
            <span class="ov-watermark">3</span>
            <div class="ov-phase-name">Specification</div>
            <div class="ov-phase-desc">Build validated specifications from discussions &mdash; filter hallucinations, enrich gaps</div>
            <div class="ov-badges">
              <span class="ov-badge ov-badge-command ov-badge-link" onclick="event.stopPropagation(); selectPhase('specification')"><span class="ov-badge-label">cmd</span>/start-specification</span>
              <span class="ov-badge ov-badge-skill ov-badge-link" onclick="event.stopPropagation(); selectPhase('skill-specification')"><span class="ov-badge-label">skill</span>technical-specification</span>
              <span class="ov-badge ov-badge-output"><span class="ov-badge-label">output</span>docs/workflow/specification/</span>
            </div>
          </div>
        </div>

        <div class="ov-connector-row">
          <svg width="816" height="56" viewBox="0 0 816 56" fill="none" xmlns="http://www.w3.org/2000/svg">
            <defs><marker id="ov-arrow-wrap" markerWidth="8" markerHeight="8" refX="4" refY="4" orient="auto"><polygon points="0,0 8,4 0,8" fill="#8b90a0" fill-opacity="0.4"/></marker></defs>
            <path d="M 696 0 L 696 18 Q 696 28 686 28 L 130 28 Q 120 28 120 38 L 120 56" stroke="#8b90a0" stroke-opacity="0.4" stroke-width="1.5" stroke-dasharray="4,3" fill="none" marker-end="url(#ov-arrow-wrap)"/>
          </svg>
        </div>

        <div class="ov-row">
          <div class="ov-card" data-phase="planning" onclick="selectPhase('planning')">
            <span class="ov-watermark">4</span>
            <div class="ov-phase-name">Planning</div>
            <div class="ov-phase-desc">Transform specs into phased plans with tasks, acceptance criteria, and dependencies</div>
            <div class="ov-badges">
              <span class="ov-badge ov-badge-command ov-badge-link" onclick="event.stopPropagation(); selectPhase('planning')"><span class="ov-badge-label">cmd</span>/start-planning</span>
              <span class="ov-badge ov-badge-skill ov-badge-link" onclick="event.stopPropagation(); selectPhase('skill-planning')"><span class="ov-badge-label">skill</span>technical-planning</span>
              <span class="ov-badge ov-badge-output"><span class="ov-badge-label">output</span>docs/workflow/planning/</span>
            </div>
          </div>
          <div class="ov-arrow-h"><svg width="48" height="12" viewBox="0 0 48 12"><line x1="4" y1="6" x2="38" y2="6" stroke="#8b90a0" stroke-opacity="0.4" stroke-width="1.5" stroke-dasharray="4,3"/><polygon points="38,2 46,6 38,10" fill="#8b90a0" fill-opacity="0.4"/></svg></div>
          <div class="ov-card" data-phase="implementation" onclick="selectPhase('implementation')">
            <span class="ov-watermark">5</span>
            <div class="ov-phase-name">Implementation</div>
            <div class="ov-phase-desc">Execute plan via agent-based TDD &mdash; executor and reviewer per task</div>
            <div class="ov-badges">
              <span class="ov-badge ov-badge-command ov-badge-link" onclick="event.stopPropagation(); selectPhase('implementation')"><span class="ov-badge-label">cmd</span>/start-implementation</span>
              <span class="ov-badge ov-badge-skill ov-badge-link" onclick="event.stopPropagation(); selectPhase('skill-implementation')"><span class="ov-badge-label">skill</span>technical-implementation</span>
              <span class="ov-badge ov-badge-output"><span class="ov-badge-label">output</span>committed code</span>
            </div>
          </div>
          <div class="ov-arrow-h"><svg width="48" height="12" viewBox="0 0 48 12"><line x1="4" y1="6" x2="38" y2="6" stroke="#8b90a0" stroke-opacity="0.4" stroke-width="1.5" stroke-dasharray="4,3"/><polygon points="38,2 46,6 38,10" fill="#8b90a0" fill-opacity="0.4"/></svg></div>
          <div class="ov-card" data-phase="review" onclick="selectPhase('review')">
            <span class="ov-watermark">6</span>
            <div class="ov-phase-name">Review</div>
            <div class="ov-phase-desc">Verify implementation against plan using parallel verification agents</div>
            <div class="ov-badges">
              <span class="ov-badge ov-badge-command ov-badge-link" onclick="event.stopPropagation(); selectPhase('review')"><span class="ov-badge-label">cmd</span>/start-review</span>
              <span class="ov-badge ov-badge-skill ov-badge-link" onclick="event.stopPropagation(); selectPhase('skill-review')"><span class="ov-badge-label">skill</span>technical-review</span>
              <span class="ov-badge ov-badge-output"><span class="ov-badge-label">output</span>review verdicts</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <svg id="svg-canvas" xmlns="http://www.w3.org/2000/svg"></svg>
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoom(1.15)">+</button>
      <button class="zoom-btn" onclick="zoom(1/1.15)">&minus;</button>
      <button class="zoom-btn" onclick="resetZoom()" style="font-size:11px">Fit</button>
      <button class="zoom-btn zoom-btn-context" id="btn-info" onclick="openInfoPanel()" title="Info" style="font-size:14px">&#9432;</button>
      <button class="zoom-btn zoom-btn-context" id="btn-source" onclick="openMdViewerFromZoom()" title="View source" style="font-size:11px;font-family:'SF Mono','Fira Code',monospace">&lt;/&gt;</button>
    </div>
    <div class="tooltip" id="tooltip"></div>
    <div id="fc-tooltip">
      <button class="fc-tooltip-source" id="fc-tooltip-source" onclick="openMdViewerFromTooltip()" title="View source">&lt;/&gt;</button>
      <div id="fc-tooltip-title"></div>
      <div id="fc-tooltip-desc"></div>
      <a id="fc-tooltip-link" class="fc-tooltip-link" href="#" onclick="navigateFromTooltip(); return false;"></a>
    </div>
    <div class="info-panel-backdrop" id="info-panel-backdrop"></div>
    <div class="info-panel" id="info-panel">
      <div class="info-panel-header">
        <div class="info-panel-title" id="info-panel-title"></div>
        <button class="info-panel-close" onclick="closeInfoPanel()">&times;</button>
      </div>
      <div class="info-panel-body" id="info-panel-body"></div>
    </div>
    <div class="md-viewer-backdrop" id="md-viewer-backdrop"></div>
    <div class="md-viewer" id="md-viewer">
      <div class="md-viewer-header">
        <button class="md-viewer-back" id="md-viewer-back" onclick="mdViewerBack()" title="Back">&larr;</button>
        <div class="md-viewer-breadcrumb" id="md-viewer-breadcrumb"></div>
        <a class="md-viewer-github" id="md-viewer-github" href="#" target="_blank" rel="noopener" title="Open on GitHub"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg> GitHub</a>
        <button class="md-viewer-close" onclick="closeMdViewer()" title="Close">&times;</button>
      </div>
      <div class="md-viewer-body" id="md-viewer-body"></div>
    </div>
  </div>

</div>

<script>
// ── State ──
const state = {
  view: 'overview',
  selectedPhase: null,
  selectedFlowchart: null,
  scale: 1,
  panX: 0, panY: 0,
  dragging: false,
  dragStart: { x: 0, y: 0 }
};

// ── Sidebar Toggle ──
function isMobile() { return window.innerWidth <= 768; }
let _desktopSidebarOpen = true;

function toggleSidebar() {
  const layout = document.querySelector('.layout');
  layout.classList.toggle('sidebar-collapsed');
  const collapsed = layout.classList.contains('sidebar-collapsed');
  if (!isMobile()) _desktopSidebarOpen = !collapsed;
  document.getElementById('sidebar-backdrop').classList.toggle('visible', !collapsed && isMobile());
}

function closeSidebar() {
  const layout = document.querySelector('.layout');
  if (!layout.classList.contains('sidebar-collapsed')) {
    layout.classList.add('sidebar-collapsed');
    document.getElementById('sidebar-backdrop').classList.remove('visible');
  }
}

function openSidebar() {
  const layout = document.querySelector('.layout');
  layout.classList.remove('sidebar-collapsed');
  if (isMobile()) {
    document.getElementById('sidebar-backdrop').classList.add('visible');
  }
}

// Backdrop click closes sidebar
document.getElementById('sidebar-backdrop').addEventListener('click', closeSidebar);

// Collapsible sidebar sections
function toggleSidebarSection(label) {
  label.classList.toggle('collapsed');
  const content = label.nextElementSibling;
  content.classList.toggle('collapsed');
}

// Auto-collapse on mobile at load
if (isMobile()) {
  document.querySelector('.layout').classList.add('sidebar-collapsed');
}

// Responsive resize handler
let _wasMobile = isMobile();
window.addEventListener('resize', () => {
  const mobile = isMobile();
  if (mobile && !_wasMobile) {
    // Entered mobile: always collapse, hide backdrop
    closeSidebar();
  } else if (!mobile && _wasMobile) {
    // Left mobile: restore desktop preference
    if (_desktopSidebarOpen) openSidebar();
    document.getElementById('sidebar-backdrop').classList.remove('visible');
  }
  _wasMobile = mobile;
});

// ── Phase Data ──
const phases = {
  research: {
    color: 'var(--ask)', bg: 'var(--ask-bg)',
    label: 'Research', cmd: '/start-research',
    complexity: 'Simple', steps: 6,
    output: 'docs/workflow/research/',
    skill: 'technical-research',
    discovery: null,
    cache: null,
    prerequisites: 'None',
    scenarios: null,
    desc: 'Explore ideas, feasibility, market and technical validation. No prerequisites, no discovery.',
  },
  discussion: {
    color: '#60a5fa', bg: 'rgba(96,165,250,0.12)',
    label: 'Discussion', cmd: '/start-discussion',
    complexity: 'Moderate', steps: 8,
    output: 'docs/workflow/discussion/{topic}.md',
    skill: 'technical-discussion',
    discovery: 'discovery-for-discussion.sh',
    cache: '.cache/research-analysis.md',
    prerequisites: 'None (but can consume research)',
    scenarios: ['fresh','research_only','discussions_only','research_and_discussions'],
    desc: 'Capture architecture decisions, debates, and edge cases. Cache-aware research analysis.',
  },
  specification: {
    color: '#34d399', bg: 'rgba(52,211,153,0.12)',
    label: 'Specification', cmd: '/start-specification',
    complexity: 'Most Complex', steps: 11,
    output: 'docs/workflow/specification/{topic}.md',
    skill: 'technical-specification',
    discovery: 'discovery-for-specification.sh',
    cache: '.cache/discussion-consolidation-analysis.md',
    prerequisites: 'Concluded discussions required',
    scenarios: ['1 concluded','multi+no specs+cache valid','multi+no specs+stale','multi+specs+cache valid','multi+specs+stale','multi+specs+no cache'],
    desc: 'The most complex command (820 lines, 11 steps). Analyzes discussion coupling, groups into features, builds validated specs.',
  },
  planning: {
    color: '#fbbf24', bg: 'rgba(251,191,36,0.12)',
    label: 'Planning', cmd: '/start-planning',
    complexity: 'Moderate', steps: 8,
    output: 'docs/workflow/planning/{topic}.md',
    skill: 'technical-planning',
    discovery: 'discovery-for-planning.sh',
    cache: null,
    prerequisites: 'Concluded specifications required',
    scenarios: ['no_specs','nothing_actionable','has_options'],
    desc: 'Transform specs into phased implementation plans. Routes by plan state (new vs existing). Surfaces cross-cutting specs.',
  },
  implementation: {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Implementation', cmd: '/start-implementation',
    complexity: 'Moderate', steps: 7,
    output: 'Code changes (tracked in plan)',
    skill: 'technical-implementation',
    discovery: 'discovery-for-implementation-and-review.sh',
    cache: null,
    prerequisites: 'Concluded plan required',
    scenarios: ['no_plans','single_plan','multiple_plans'],
    desc: 'Execute plans via strict TDD. Three-section plan classification with unblock escape hatch. Gates: external deps, environment setup.',
  },
  review: {
    color: '#f472b6', bg: 'rgba(244,114,182,0.12)',
    label: 'Review', cmd: '/start-review',
    complexity: 'Moderate', steps: 5,
    output: 'Review feedback (approve/changes/comments)',
    skill: 'technical-review',
    discovery: 'discovery-for-implementation-and-review.sh',
    cache: null,
    prerequisites: 'Implementation of a plan',
    scenarios: ['no_plans','single_plan','multiple_plans'],
    desc: 'Validate implementation against plan. Uses parallel review-task-verifier subagents (one per task).',
  },
  'start-feature': {
    color: '#818cf8', bg: 'rgba(129,140,248,0.12)',
    label: 'Start Feature', cmd: '/start-feature',
    complexity: 'Shortcut',
    desc: 'Bypass phases 1-2. Gather feature context inline, invoke specification skill directly.',
  },
  'link-deps': {
    color: '#94a3b8', bg: 'rgba(148,163,184,0.12)',
    label: 'Link Dependencies', cmd: '/link-dependencies',
    complexity: 'Cross-plan',
    desc: 'Wire up cross-topic dependencies across all plans.',
  },
  'status': {
    color: '#94a3b8', bg: 'rgba(148,163,184,0.12)',
    label: 'Status', cmd: '/status',
    complexity: 'Utility',
    desc: 'Quick overview. Scans all workflow dirs, shows table by topic across phases.',
  },
  'view-plan': {
    color: '#94a3b8', bg: 'rgba(148,163,184,0.12)',
    label: 'View Plan', cmd: '/view-plan',
    complexity: 'Utility',
    desc: 'Read a plan, load its output format, display phases/tasks/status.',
  },
  'migrate': {
    color: '#6c8aff', bg: 'rgba(108,138,255,0.12)',
    label: 'Migrate', cmd: '/migrate',
    complexity: 'System',
    desc: 'Runs as Step 0 of every workflow command. Keeps workflow files in sync with system design.',
  },
  'skill-research': {
    color: 'var(--ask)', bg: 'var(--ask-bg)',
    label: 'Research Skill', cmd: 'technical-research',
  },
  'skill-discussion': {
    color: '#60a5fa', bg: 'rgba(96,165,250,0.12)',
    label: 'Discussion Skill', cmd: 'technical-discussion',
  },
  'skill-specification': {
    color: '#34d399', bg: 'rgba(52,211,153,0.12)',
    label: 'Specification Skill', cmd: 'technical-specification',
  },
  'skill-planning': {
    color: '#fbbf24', bg: 'rgba(251,191,36,0.12)',
    label: 'Planning Skill', cmd: 'technical-planning',
  },
  'skill-implementation': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Implementation Skill', cmd: 'technical-implementation',
  },
  'skill-review': {
    color: '#f472b6', bg: 'rgba(244,114,182,0.12)',
    label: 'Review Skill', cmd: 'technical-review',
  },
  'planning-phase-designer': {
    color: '#fbbf24', bg: 'rgba(251,191,36,0.12)',
    label: 'Phase Designer',
    desc: 'Subagent that designs implementation phases from a specification. Invoked during plan construction.',
  },
  'planning-task-designer': {
    color: '#fbbf24', bg: 'rgba(251,191,36,0.12)',
    label: 'Task Designer',
    desc: 'Subagent that breaks phases into task lists with edge cases. Invoked during plan construction.',
  },
  'planning-task-author': {
    color: '#fbbf24', bg: 'rgba(251,191,36,0.12)',
    label: 'Task Author',
    desc: 'Subagent that writes full task detail in the chosen output format. Invoked during plan construction.',
  },
  'planning-dependency-grapher': {
    color: '#fbbf24', bg: 'rgba(251,191,36,0.12)',
    label: 'Dependency Grapher',
    desc: 'Subagent that analyzes task dependencies, detects cycles, and assigns priorities.',
  },
  'implementation-task-executor': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Task Executor',
    desc: 'Subagent that implements a single task via strict TDD. Returns structured completion report.',
  },
  'implementation-task-reviewer': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Task Reviewer',
    desc: 'Subagent that independently reviews a task for spec conformance and code quality.',
  },
  'implementation-analysis-duplication': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Analysis: Duplication',
    desc: 'Analysis agent that hunts for cross-file duplication, near-duplicate logic, and extraction candidates.',
  },
  'implementation-analysis-standards': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Analysis: Standards',
    desc: 'Analysis agent that checks spec conformance and project convention compliance.',
  },
  'implementation-analysis-architecture': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Analysis: Architecture',
    desc: 'Analysis agent that evaluates API surface quality, module structure, and seam quality.',
  },
  'implementation-analysis-synthesizer': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Analysis: Synthesizer',
    desc: 'Synthesizes findings from 3 analysis agents into deduplicated, normalized tasks for approval.',
  },
  'implementation-analysis-task-writer': {
    color: '#f97316', bg: 'rgba(249,115,22,0.12)',
    label: 'Analysis: Task Writer',
    desc: 'Creates plan tasks from approved analysis findings using the format authoring adapter.',
  },
  'review-task-verifier': {
    color: '#f472b6', bg: 'rgba(244,114,182,0.12)',
    label: 'Task Verifier',
    desc: 'Subagent that verifies a single task implementation against plan and spec. Spawned in parallel.',
  },
};

// ── SVG Node Definitions ──
const OVERVIEW_NODES = [
  // Phase pipeline (vertical, centered) — click any phase to drill into its flowchart
  { id: 'research', label: '1. Research', subtitle: '/start-research', x: 280, y: 30, w: 240, h: 58, type: 'phase', color: 'var(--research)', bg: 'var(--research-bg)', phase: 'research' },
  { id: 'discussion', label: '2. Discussion', subtitle: '/start-discussion', x: 280, y: 128, w: 240, h: 58, type: 'phase', color: 'var(--discussion)', bg: 'var(--discussion-bg)', phase: 'discussion' },
  { id: 'specification', label: '3. Specification', subtitle: '/start-specification', x: 280, y: 226, w: 240, h: 58, type: 'phase', color: 'var(--specification)', bg: 'var(--specification-bg)', phase: 'specification' },
  { id: 'planning', label: '4. Planning', subtitle: '/start-planning', x: 280, y: 324, w: 240, h: 58, type: 'phase', color: 'var(--planning)', bg: 'var(--planning-bg)', phase: 'planning' },
  { id: 'implementation', label: '5. Implementation', subtitle: '/start-implementation', x: 280, y: 422, w: 240, h: 58, type: 'phase', color: 'var(--implementation)', bg: 'var(--implementation-bg)', phase: 'implementation' },
  { id: 'review', label: '6. Review', subtitle: '/start-review', x: 280, y: 520, w: 240, h: 58, type: 'phase', color: 'var(--review)', bg: 'var(--review-bg)', phase: 'review' },

  // Shortcut entry
  { id: 'start-feature', label: '/start-feature', subtitle: 'Skip research & discussion', x: 20, y: 234, w: 210, h: 42, type: 'standalone', color: '#818cf8', bg: 'rgba(129,140,248,0.12)', phase: 'start-feature' },
];

const OVERVIEW_CONNECTIONS = [
  // Phase-to-phase flow with artifact labels
  { from: 'research', to: 'discussion', type: 'flow', label: 'research docs' },
  { from: 'discussion', to: 'specification', type: 'flow', label: 'discussion docs' },
  { from: 'specification', to: 'planning', type: 'flow', label: 'specification' },
  { from: 'planning', to: 'implementation', type: 'flow', label: 'plan + tasks' },
  { from: 'implementation', to: 'review', type: 'flow', label: 'code changes' },

  // Shortcut: /start-feature enters at specification
  { from: 'start-feature', to: 'specification', type: 'shortcut', label: 'shortcut' },
];

// ── Dagre-based Flowchart Layout ──
let _layoutCache = {};

function computeFlowchartLayout(key) {
  if (_layoutCache[key]) return _layoutCache[key];

  const fc = FLOWCHARTS[key];
  const g = new dagre.graphlib.Graph();
  g.setGraph({ rankdir: 'TB', nodesep: 50, ranksep: 60, edgesep: 25, marginx: 30, marginy: 30 });
  g.setDefaultEdgeLabel(() => ({}));

  fc.nodes.forEach(n => {
    g.setNode(n.id, { width: n.w, height: n.h });
  });

  fc.connections.forEach(c => {
    const opts = { label: c.label || '' };
    if (c.weight) opts.weight = c.weight;
    if (c.minlen) opts.minlen = c.minlen;
    g.setEdge(c.from, c.to, opts);
  });

  dagre.layout(g);

  const positioned = fc.nodes.map(n => {
    const dn = g.node(n.id);
    return { ...n, x: dn.x - n.w / 2, y: dn.y - n.h / 2 };
  });

  const edgePoints = {};
  fc.connections.forEach(c => {
    const de = g.edge(c.from, c.to);
    edgePoints[c.from + '->' + c.to] = de ? de.points : [];
  });

  const result = { nodes: positioned, edgePoints };
  _layoutCache[key] = result;
  return result;
}

// ── Flowchart Data (dagre-compatible: w/h, no row/col) ──
const FLOWCHARTS = {
  research: {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for the /start-research command.' },
      { id: 'migrate', label: 'Run /migrate', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Step 0: Run migrations to keep workflow files in sync. Mandatory before proceeding.' },
      { id: 'ask1', label: "ASK: What's on your mind?", w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 1: Ask user for their seed idea - what topic they want to explore and what prompted it.' },
      { id: 'ask2', label: 'ASK: What do you know?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 2: Understand current knowledge - any initial thoughts, research, or constraints.' },
      { id: 'ask3', label: 'ASK: Where to start?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 3: Determine starting point - technical feasibility, market, business, or open exploration.' },
      { id: 'ask4', label: 'ASK: Constraints?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 4: Gather final context - any constraints or context to know upfront.' },
      { id: 'skill', label: 'Invoke research skill', w: 200, h: 44, color: 'var(--skill)', bg: 'var(--skill-bg)', desc: 'Step 5: Invoke the technical-research skill with all gathered context.', skillLink: 'skill-research' },
    ],
    connections: [
      { from: 'start', to: 'migrate' },
      { from: 'migrate', to: 'ask1' },
      { from: 'ask1', to: 'ask2' },
      { from: 'ask2', to: 'ask3' },
      { from: 'ask3', to: 'ask4' },
      { from: 'ask4', to: 'skill', type: 'transition' },
    ]
  },
  discussion: {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /start-discussion.' },
      { id: 'migrate', label: 'Run /migrate', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Step 0: Run migrations.' },
      { id: 'discovery', label: 'Run discovery script', w: 180, h: 44, color: 'var(--discovery)', bg: 'var(--discovery-bg)', desc: 'Step 1: Run discovery-for-discussion.sh. Scans research files, existing discussions, and cache. Outputs YAML with scenario classification.' },
      { id: 'scenario', label: 'Scenario?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 2: Route based on scenario from discovery: fresh, research_only, discussions_only, or research_and_discussions.' },
      { id: 'fresh', label: 'ASK: Topic name', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Fresh scenario: No research or discussions exist. Ask user for topic, skip to gather context.' },
      { id: 'has-research', label: 'Cache valid?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 3: Check research analysis cache status (valid/stale/none) before presenting options.' },
      { id: 'disc-only', label: 'Discussions only', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Discussions-only scenario: No research exists, skip research analysis.' },
      { id: 'load-cache', label: 'Load cached analysis', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Cache valid: Load cached research-analysis.md and present topics.' },
      { id: 'analyze', label: 'Analyze research', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Cache stale/none: Read each research file, extract themes, save to cache with checksums.' },
      { id: 'present', label: 'Present options menu', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 4: Show workflow state and present options. Menu varies by scenario (2-4 options).' },
      { id: 'choice', label: 'User choice?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 5: Route based on user selection from options menu.' },
      { id: 'from-res', label: 'From research', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'User chose to start from a research topic. Identify which topic was selected.' },
      { id: 'continue', label: 'Continue discussion', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'User chose to continue an existing discussion. Read existing doc first.' },
      { id: 'refresh', label: 'Refresh cache', w: 180, h: 44, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'User chose refresh: Delete cache file, return to Step 3 to re-analyze research.' },
      { id: 'gather', label: 'ASK: Context & constraints', w: 205, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 6: Gather context - core problem/decision, constraints, codebase files to review.' },
      { id: 'skill', label: 'Invoke discussion skill', w: 200, h: 44, color: 'var(--skill)', bg: 'var(--skill-bg)', desc: 'Step 7: Invoke technical-discussion skill with gathered context.', skillLink: 'skill-discussion' },
    ],
    connections: [
      { from: 'start', to: 'migrate' },
      { from: 'migrate', to: 'discovery' },
      { from: 'discovery', to: 'scenario' },
      { from: 'scenario', to: 'fresh', label: 'fresh' },
      { from: 'scenario', to: 'has-research', label: 'research' },
      { from: 'scenario', to: 'disc-only', label: 'disc only' },
      { from: 'has-research', to: 'load-cache', type: 'yes', label: 'valid' },
      { from: 'has-research', to: 'analyze', type: 'no', label: 'stale' },
      { from: 'load-cache', to: 'present' },
      { from: 'analyze', to: 'present' },
      { from: 'disc-only', to: 'present' },
      { from: 'fresh', to: 'gather' },
      { from: 'present', to: 'choice' },
      { from: 'choice', to: 'from-res', label: 'research' },
      { from: 'choice', to: 'continue', label: 'continue' },
      { from: 'choice', to: 'gather', label: 'fresh' },
      { from: 'choice', to: 'refresh', label: 'refresh' },
      { from: 'from-res', to: 'gather' },
      { from: 'continue', to: 'gather' },
      { from: 'refresh', to: 'analyze', type: 'backloop' },
      { from: 'gather', to: 'skill', type: 'transition' },
    ]
  },
  specification: {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /start-specification.' },
      { id: 'migrate', label: 'Run /migrate', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Step 0: Run migrations.' },
      { id: 'discovery', label: 'Run discovery script', w: 180, h: 44, color: 'var(--discovery)', bg: 'var(--discovery-bg)', desc: 'Step 1: Run discovery-for-specification.sh. Scans discussions (with has_individual_spec check), specifications, and cache.' },
      { id: 'gate-disc', label: 'Discussions?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 2 Gate: Do any discussions exist? If not, STOP.' },
      { id: 'stop-no-disc', label: 'STOP: No discussions', shape: 'stop', w: 170, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: No discussions found. User must run /start-discussion first.' },
      { id: 'gate-concluded', label: 'Concluded?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 2 Gate: Are any discussions concluded? If not, STOP.' },
      { id: 'stop-no-conc', label: 'STOP: None concluded', shape: 'stop', w: 170, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: Discussions exist but none concluded. Complete discussion phase first.' },
      { id: 'count', label: 'How many?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 3: Route based on concluded discussion count. 1 = auto-select, multiple = check specs/cache.' },
      { id: 'auto-select', label: 'Auto-select single', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Only one concluded discussion. Auto-select it, skip to confirm.' },
      { id: 'multi-route', label: 'Specs exist?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Multiple concluded: Do existing specifications exist? Routes to different options.' },
      { id: 'no-specs-cache', label: 'Cache valid?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'No specs + multiple discussions: Check consolidation cache. Valid = show groupings, stale/none = gather context first.' },
      { id: 'specs-options', label: 'ASK: Continue / Regroup', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Specs exist: Offer continue existing spec, select from groupings (if cache valid), or re-analyze.' },
      { id: 'gather-ctx', label: 'Gather analysis context', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 4: Ask about project structure and topic relationships before analysis.' },
      { id: 'analyze', label: 'Analyze discussions', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 6: Read ALL concluded discussions. Analyze coupling (data, behavioral, conceptual). Group into specs. Save to cache.' },
      { id: 'show-groups', label: 'Present groupings', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 7: Present recommended groupings with full status info and 5 options.' },
      { id: 'group-choice', label: 'Grouping choice?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 8: Route based on user grouping choice: proceed, combine, single, individual, or refresh.' },
      { id: 'refresh', label: 'Refresh cache', w: 180, h: 44, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Delete cache, return to Step 6 (analyze discussions) for fresh analysis.' },
      { id: 'proceed', label: 'ASK: Which grouping?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Proceed as recommended: Ask which grouping to start with.' },
      { id: 'combine', label: 'ASK: Custom groupings', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Combine differently: User describes groupings. Impact analysis if 2+ specs affected.' },
      { id: 'single', label: 'Use "unified" name', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Single specification: Consolidate ALL discussions into one "unified" spec.' },
      { id: 'individual', label: 'ASK: Which discussion?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Individual specifications: 1:1 mapping. Ask which discussion to specify.' },
      { id: 'confirm', label: 'ASK: Confirm selection', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 9: Confirm selection - show sources, output path, supersede info. Wait for y/n.' },
      { id: 'add-ctx', label: 'ASK: Additional context', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 10: Gather additional context, priorities, constraints since discussion concluded.' },
      { id: 'skill', label: 'Invoke specification skill', w: 210, h: 44, color: 'var(--skill)', bg: 'var(--skill-bg)', desc: 'Step 11: Invoke technical-specification skill with all gathered context.', skillLink: 'skill-specification' },
    ],
    connections: [
      { from: 'start', to: 'migrate' },
      { from: 'migrate', to: 'discovery' },
      { from: 'discovery', to: 'gate-disc' },
      { from: 'gate-disc', to: 'gate-concluded', type: 'yes', label: 'exist', weight: 2 },
      { from: 'gate-disc', to: 'stop-no-disc', type: 'no', label: 'none' },
      { from: 'gate-concluded', to: 'count', type: 'yes', label: 'yes', weight: 2 },
      { from: 'gate-concluded', to: 'stop-no-conc', type: 'no', label: 'none' },
      { from: 'count', to: 'auto-select', label: 'one' },
      { from: 'count', to: 'multi-route', label: 'multi' },
      { from: 'multi-route', to: 'no-specs-cache', type: 'no', label: 'no specs' },
      { from: 'multi-route', to: 'specs-options', type: 'yes', label: 'specs exist' },
      { from: 'no-specs-cache', to: 'show-groups', type: 'yes', label: 'valid' },
      { from: 'no-specs-cache', to: 'gather-ctx', type: 'no', label: 'stale' },
      { from: 'specs-options', to: 'show-groups' },
      { from: 'gather-ctx', to: 'analyze' },
      { from: 'analyze', to: 'show-groups' },
      { from: 'show-groups', to: 'group-choice' },
      { from: 'group-choice', to: 'proceed', label: 'proceed' },
      { from: 'group-choice', to: 'combine', label: 'combine' },
      { from: 'group-choice', to: 'single', label: 'single' },
      { from: 'group-choice', to: 'individual', label: 'individual' },
      { from: 'group-choice', to: 'refresh', label: 'refresh' },
      { from: 'refresh', to: 'analyze', type: 'backloop' },
      { from: 'proceed', to: 'confirm' },
      { from: 'combine', to: 'confirm' },
      { from: 'single', to: 'confirm' },
      { from: 'individual', to: 'confirm' },
      { from: 'auto-select', to: 'confirm' },
      { from: 'confirm', to: 'add-ctx' },
      { from: 'add-ctx', to: 'skill', type: 'transition' },
    ]
  },
  planning: {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /start-planning.' },
      { id: 'migrate', label: 'Run /migrate', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Step 0: Run migrations.' },
      { id: 'discovery', label: 'Run discovery script', w: 180, h: 44, color: 'var(--discovery)', bg: 'var(--discovery-bg)', desc: 'Step 1: Run discovery-for-planning.sh. Scans specs (feature vs cross-cutting), counts ready specs, checks existing plans.' },
      { id: 'scenario', label: 'Scenario?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 2: Route based on scenario: no_specs, nothing_actionable, or has_options.' },
      { id: 'stop-no-spec', label: 'STOP: No specs', shape: 'stop', w: 150, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: No specifications found. Run /start-specification first.' },
      { id: 'stop-none-ready', label: 'STOP: None actionable', shape: 'stop', w: 175, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'nothing_actionable: Specs exist but none actionable. Show state and suggest completing in-progress specs.' },
      { id: 'present', label: 'Present options', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 3: Present available specs (+new, ▶continue, >review) and not plannable specs. Single auto-selects, multiple asks.' },
      { id: 'plan-state', label: 'Existing plan?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 4: Route by plan state. New plan gathers context first; existing plan skips straight to skill invocation.' },
      { id: 'gather', label: 'ASK: Additional context', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 5: Gather additional context, priorities, or constraint changes. Only for new plans.' },
      { id: 'cross-cut', label: 'Surface cross-cutting specs', w: 215, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 6: Read concluded cross-cutting specs and surface relevant ones as reference context for planning. Only for new plans.' },
      { id: 'skill', label: 'Invoke planning skill', w: 200, h: 44, color: 'var(--skill)', bg: 'var(--skill-bg)', desc: 'Step 7: Invoke technical-planning skill. Handles format selection, phases, tasks, dependencies.', skillLink: 'skill-planning' },
    ],
    connections: [
      { from: 'start', to: 'migrate' },
      { from: 'migrate', to: 'discovery' },
      { from: 'discovery', to: 'scenario' },
      { from: 'scenario', to: 'present', type: 'yes', label: 'has options', weight: 2 },
      { from: 'scenario', to: 'stop-no-spec', type: 'no', label: 'no specs' },
      { from: 'scenario', to: 'stop-none-ready', label: 'none actionable' },
      { from: 'present', to: 'plan-state' },
      { from: 'plan-state', to: 'gather', type: 'no', label: 'new' },
      { from: 'plan-state', to: 'skill', type: 'yes', label: 'exists' },
      { from: 'gather', to: 'cross-cut' },
      { from: 'cross-cut', to: 'skill', type: 'transition' },
    ]
  },
  implementation: {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /start-implementation.' },
      { id: 'migrate', label: 'Run /migrate', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Step 0: Run migrations.' },
      { id: 'discovery', label: 'Run discovery script', w: 180, h: 44, color: 'var(--discovery)', bg: 'var(--discovery-bg)', desc: 'Step 1: Run discovery-for-implementation-and-review.sh. Scans plans, implementation tracking, dependencies, and environment setup.' },
      { id: 'scenario', label: 'Plans?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 2: Route on scenario — no_plans, single_plan, or multiple_plans.' },
      { id: 'stop-no-plan', label: 'STOP: No plans', shape: 'stop', w: 150, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: No plans found. Run /start-planning first.' },
      { id: 'present', label: 'Present plans', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 3: Classify plans into Implementable (▶ in-progress, + new), Implemented (> completed), and Not implementable (· blocked/not concluded). Number selectable entries. Includes unblock escape hatch for externally satisfied deps.' },
      { id: 'select', label: 'Select plan', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Single implementable = auto-select, otherwise ask user. Implemented plans can be re-selected.' },
      { id: 'unblock', label: 'ASK: Unblock dep', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'User requests unblock: identify plan and dep, confirm, mark satisfied_externally in frontmatter, commit, re-present.' },
      { id: 'gate-deps', label: 'Ext deps OK?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 4: Confirm external dependencies satisfied. Pre-analyzed by discovery script. Escape hatch: mark as satisfied externally.' },
      { id: 'block-deps', label: 'BLOCK: Deps missing', shape: 'stop', w: 180, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Dependencies blocking. Show unresolved and incomplete. Offer: implement first, mark satisfied externally, or run /link-dependencies.' },
      { id: 'escape', label: 'Mark satisfied externally', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Escape hatch: User says dep was implemented outside workflow. Update plan frontmatter, re-check.' },
      { id: 'gate-env', label: 'Env setup?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 5: Check environment setup. Info gathering only — does not execute setup.' },
      { id: 'create-env', label: 'ASK: Setup instructions', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Setup file missing: Ask user for setup instructions, save to environment-setup.md and commit.' },
      { id: 'env-ok', label: 'Environment noted', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Setup exists (no special setup or has instructions). Note for skill handoff.' },
      { id: 'skill', label: 'Invoke implementation skill', w: 215, h: 44, color: 'var(--skill)', bg: 'var(--skill-bg)', desc: 'Step 6: Invoke technical-implementation skill with plan, format, spec, tracking state, deps, and env info.', skillLink: 'skill-implementation' },
    ],
    connections: [
      { from: 'start', to: 'migrate' },
      { from: 'migrate', to: 'discovery' },
      { from: 'discovery', to: 'scenario' },
      { from: 'scenario', to: 'stop-no-plan', type: 'no', label: 'no plans' },
      { from: 'scenario', to: 'present', type: 'yes', label: 'exist', weight: 2 },
      { from: 'present', to: 'select', weight: 2 },
      { from: 'select', to: 'unblock', label: 'unblock', port: 'left' },
      { from: 'unblock', to: 'present', type: 'backloop' },
      { from: 'select', to: 'gate-deps', label: 'proceed', weight: 2, port: 'bottom' },
      { from: 'gate-deps', to: 'block-deps', type: 'no', label: 'blocked', port: 'lower-left' },
      { from: 'block-deps', to: 'escape' },
      { from: 'escape', to: 'gate-deps', type: 'backloop' },
      { from: 'gate-deps', to: 'gate-env', type: 'yes', label: 'ok', weight: 2, port: 'lower-right' },
      { from: 'gate-env', to: 'create-env', label: 'missing' },
      { from: 'gate-env', to: 'env-ok', label: 'exists' },
      { from: 'create-env', to: 'skill', type: 'transition' },
      { from: 'env-ok', to: 'skill', type: 'transition' },
    ]
  },
  review: {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /start-review.' },
      { id: 'migrate', label: 'Run /migrate', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Step 0: Run migrations.' },
      { id: 'discovery', label: 'Run discovery script', w: 180, h: 44, color: 'var(--discovery)', bg: 'var(--discovery-bg)', desc: 'Step 1: Run shared discovery-for-implementation-and-review.sh. Scans plans.' },
      { id: 'scenario', label: 'Plans?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 2: Do any plans exist? Gate check.' },
      { id: 'stop', label: 'STOP: No plans', shape: 'stop', w: 150, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: No plans found. Run /start-planning first.' },
      { id: 'select', label: 'Select plan', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 3: Single plan = auto-select, multiple = ask user.' },
      { id: 'auto', label: 'Auto-select single', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Only one plan. Auto-select it.' },
      { id: 'ask', label: 'ASK: Which plan?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Multiple plans. Ask user which to review.' },
      { id: 'scope', label: 'ASK: Review scope', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 4: Choose scope - all changes since plan, specific dirs/files, or from git status.' },
      { id: 'skill', label: 'Invoke review skill', w: 200, h: 44, color: 'var(--skill)', bg: 'var(--skill-bg)', desc: 'Step 5: Invoke technical-review skill. Reads plan, spec, extracts ALL tasks.', skillLink: 'skill-review' },
    ],
    connections: [
      { from: 'start', to: 'migrate' },
      { from: 'migrate', to: 'discovery' },
      { from: 'discovery', to: 'scenario' },
      { from: 'scenario', to: 'select', type: 'yes', label: 'exist', weight: 2 },
      { from: 'scenario', to: 'stop', type: 'no', label: 'none' },
      { from: 'select', to: 'auto', label: 'single' },
      { from: 'select', to: 'ask', label: 'multiple' },
      { from: 'auto', to: 'scope' },
      { from: 'ask', to: 'scope' },
      { from: 'scope', to: 'skill', type: 'transition' },
    ]
  },
  'start-feature': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /start-feature. No migration step (standalone command).' },
      { id: 'gather', label: 'ASK: Feature context', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 1: Gather feature context - what, scope, constraints. Can skip if already provided inline.' },
      { id: 'name', label: 'ASK: Suggest topic name', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 2: Suggest a topic name for the specification file based on feature description.' },
      { id: 'check', label: 'Name conflict?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 3: Check docs/workflow/specification/ for naming conflicts.' },
      { id: 'conflict', label: 'ASK: Append / rename / replace', w: 230, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Conflict found: Ask user to append to existing, choose different name, or replace.' },
      { id: 'skill', label: 'Invoke specification skill', w: 210, h: 44, color: 'var(--skill)', bg: 'var(--skill-bg)', desc: 'Step 4: Invoke technical-specification skill with inline feature context (no discussion doc).', skillLink: 'skill-specification' },
    ],
    connections: [
      { from: 'start', to: 'gather' },
      { from: 'gather', to: 'name' },
      { from: 'name', to: 'check' },
      { from: 'check', to: 'conflict', type: 'yes', label: 'conflict' },
      { from: 'check', to: 'skill', type: 'no', label: 'ok' },
      { from: 'conflict', to: 'skill' },
    ]
  },
  'link-deps': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /link-dependencies. No migration step.' },
      { id: 'discover', label: 'Discover all plans', w: 180, h: 44, color: 'var(--discovery)', bg: 'var(--discovery-bg)', desc: 'Step 1: Scan docs/workflow/planning/ for all plan files. Extract format metadata.' },
      { id: 'gate-count', label: 'Plans >= 2?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Gate: Need at least 2 plans for cross-topic linking. 0-1 = STOP.' },
      { id: 'stop-count', label: 'STOP: Need 2+ plans', shape: 'stop', w: 150, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: Fewer than 2 plans. Cannot link across topics.' },
      { id: 'gate-format', label: 'Same format?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Gate: All plans must use the same output format. Mixed formats = STOP.' },
      { id: 'stop-format', label: 'STOP: Mixed formats', shape: 'stop', w: 150, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: Plans use different formats. Consolidate first.' },
      { id: 'extract', label: 'Extract ext dependencies', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 3: Read External Dependencies section from each plan. Categorize as unresolved/resolved/satisfied.' },
      { id: 'match', label: 'Match deps to tasks', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 4: For each unresolved dep, search other plans for matching tasks using output format querying.' },
      { id: 'wire', label: 'Wire up dependencies', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 5: Update plan index files with resolved task IDs. Create blocking relationships.' },
      { id: 'bidir', label: 'Bidirectional check', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 6: Check reverse dependencies. If plan X depends on Y, does Y know about it?' },
      { id: 'report', label: 'Report results', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 7: Summary of resolved, already-resolved, satisfied, and still-unresolved deps.' },
      { id: 'commit', label: 'ASK: Commit changes?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Step 8: Ask user to commit dependency updates.' },
      { id: 'end', label: 'Plans updated', shape: 'pill', w: 150, h: 40, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Output: Updated plan files with wired-up cross-topic dependencies.' },
    ],
    connections: [
      { from: 'start', to: 'discover' },
      { from: 'discover', to: 'gate-count' },
      { from: 'gate-count', to: 'gate-format', type: 'yes', label: '>= 2', weight: 2 },
      { from: 'gate-count', to: 'stop-count', type: 'no', label: '< 2' },
      { from: 'gate-format', to: 'extract', type: 'yes', label: 'match', weight: 2 },
      { from: 'gate-format', to: 'stop-format', type: 'no', label: 'mixed' },
      { from: 'extract', to: 'match' },
      { from: 'match', to: 'wire' },
      { from: 'wire', to: 'bidir' },
      { from: 'bidir', to: 'report' },
      { from: 'report', to: 'commit' },
      { from: 'commit', to: 'end' },
    ]
  },
  'skill-research': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry: technical-research skill receives gathered context from command.' },
      { id: 'validate', label: 'Validate inputs', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Verify topic/idea is provided. If missing or vague, stop and ask.' },
      { id: 'init', label: 'Initialize doc', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Create exploration.md with YAML frontmatter (topic + date). No status field.' },
      { id: 'ask', label: 'ASK question', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Ask one research question at a time. Probe feasibility, hidden complexity, assumptions.' },
      { id: 'discuss', label: 'Discuss answer', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Engage with the answer. Follow tangents. Challenge assumptions. Be honest about risks.' },
      { id: 'document', label: 'Document insight', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Capture the insight in the research file. Only what was discussed, no embellishment.' },
      { id: 'commit', label: 'Commit & push', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Commit immediately. Every insight pushed before the next question. Unpushed work is lost.' },
      { id: 'more', label: 'More to explore?', shape: 'diamond', w: 120, h: 120, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Periodic review: more questions? Themes emerging? Ready for discussion/spec?' },
      { id: 'split', label: 'Themes emerging?', shape: 'diamond', w: 120, h: 120, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Over multiple sessions, topics may become distinct. Split if so.' },
      { id: 'split-files', label: 'Split into files', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Split exploration.md into semantic files (market-landscape.md, technical-feasibility.md, etc).' },
      { id: 'end', label: 'research/ output', shape: 'pill', w: 150, h: 40, color: 'var(--research)', bg: 'var(--research-bg)', desc: 'Output: docs/workflow/research/ files. Research never "concludes" — always open-ended.' },
      { id: 'next', label: 'Invoke /start-discussion', desc: 'Navigate to the discussion command to begin capturing architecture decisions from research output.', w: 200, h: 44, color: 'var(--next)', bg: 'var(--next-bg)', skillLink: 'discussion' },
    ],
    connections: [
      { from: 'start', to: 'validate' },
      { from: 'validate', to: 'init' },
      { from: 'init', to: 'ask' },
      { from: 'ask', to: 'discuss' },
      { from: 'discuss', to: 'document' },
      { from: 'document', to: 'commit' },
      { from: 'commit', to: 'more' },
      { from: 'more', to: 'ask', type: 'backloop', label: 'yes' },
      { from: 'more', to: 'split', type: 'no', label: 'done' },
      { from: 'split', to: 'split-files', type: 'yes', label: 'yes' },
      { from: 'split', to: 'end', type: 'no', label: 'no' },
      { from: 'split-files', to: 'end' },
      { from: 'end', to: 'next', type: 'transition' },
    ]
  },
  'skill-discussion': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry: technical-discussion skill receives context from command.' },
      { id: 'validate', label: 'Validate inputs', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Verify source material and topic name. Stop if missing.' },
      { id: 'init', label: 'Initialize document', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Create discussion/{topic}.md with YAML frontmatter. Set status: active.' },
      { id: 'engage', label: 'Engage on topic', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Present topic for discussion. Ask probing questions one at a time.' },
      { id: 'capture', label: 'Capture decisions', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Record options considered, journey of exploration, and decisions (even provisional ones) with rationale.' },
      { id: 'document', label: 'Write to disk', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Write reasoning and context to the discussion file. Not a verbatim transcript — capture the journey, not the dialogue.' },
      { id: 'commit', label: 'Commit & push', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Commit at natural breaks. Never batch — context refresh loses unpushed work.' },
      { id: 'more', label: 'More topics?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Are there more topics to discuss?' },
      { id: 'conclude', label: 'Conclude discussion', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Set status: concluded. All decisions documented. Ready for specification.' },
      { id: 'end', label: 'discussion/{topic}.md', shape: 'pill', w: 175, h: 40, color: 'var(--discussion)', bg: 'var(--discussion-bg)', desc: 'Output: Concluded discussion document ready for specification phase.' },
      { id: 'next', label: 'Invoke /start-specification', desc: 'Navigate to the specification command to build a validated spec from concluded discussions.', w: 210, h: 44, color: 'var(--next)', bg: 'var(--next-bg)', skillLink: 'specification' },
    ],
    connections: [
      { from: 'start', to: 'validate' },
      { from: 'validate', to: 'init' },
      { from: 'init', to: 'engage' },
      { from: 'engage', to: 'capture' },
      { from: 'capture', to: 'document' },
      { from: 'document', to: 'commit' },
      { from: 'commit', to: 'more' },
      { from: 'more', to: 'engage', type: 'backloop', label: 'yes', port: 'right' },
      { from: 'more', to: 'conclude', type: 'no', label: 'done' },
      { from: 'conclude', to: 'end' },
      { from: 'end', to: 'next', type: 'transition' },
    ]
  },
  'skill-specification': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry: technical-specification skill receives source material and topic.' },
      { id: 'validate', label: 'Validate inputs', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Verify source material and topic name. Multiple sources OK — extract from ALL.' },
      { id: 'load-guide', label: 'Load spec guide', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Load specification-guide.md for structure and section requirements.' },
      { id: 'extract', label: 'Extract from sources', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Re-scan ALL source materials for current topic. Search keywords. Collect everything.' },
      { id: 'filter', label: 'Filter & validate', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Source material may contain hallucinations or inaccuracies. Validate before including.' },
      { id: 'enrich', label: 'Enrich gaps', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Identify gaps in source material. Fill through discussion with user.' },
      { id: 'present', label: 'Present to user', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Present synthesized content in spec format. ONE topic at a time.' },
      { id: 'wait', label: 'Approved?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'CRITICAL: STOP and WAIT for explicit user approval. Never write without approval.' },
      { id: 'log', label: 'Log to specification', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write approved content verbatim to specification file. No silent modifications.' },
      { id: 'more-topics', label: 'More topics?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Are there more specification topics to cover from the sources?' },
      { id: 'final-review', label: 'Final review', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Review ALL sources against spec. Flag potentially missed content.' },
      { id: 'supersede', label: 'Supersede source specs', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'If sources included existing specs, mark them superseded_by new spec.' },
      { id: 'signoff', label: 'User sign-off', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Final user approval of the complete specification.' },
      { id: 'end', label: 'specification/{topic}.md', shape: 'pill', w: 190, h: 40, color: 'var(--specification)', bg: 'var(--specification-bg)', desc: 'Output: Validated, standalone specification — the golden document.' },
      { id: 'next', label: 'Invoke /start-planning', desc: 'Navigate to the planning command to create phased implementation tasks from the specification.', w: 200, h: 44, color: 'var(--next)', bg: 'var(--next-bg)', skillLink: 'planning' },
    ],
    connections: [
      { from: 'start', to: 'validate' },
      { from: 'validate', to: 'load-guide' },
      { from: 'load-guide', to: 'extract' },
      { from: 'extract', to: 'filter' },
      { from: 'filter', to: 'enrich' },
      { from: 'enrich', to: 'present' },
      { from: 'present', to: 'wait' },
      { from: 'wait', to: 'present', type: 'backloop', label: 'revise', port: 'upper-right' },
      { from: 'wait', to: 'log', type: 'yes', label: 'approved', weight: 2 },
      { from: 'log', to: 'more-topics' },
      { from: 'more-topics', to: 'extract', type: 'backloop', label: 'yes', port: 'upper-right' },
      { from: 'more-topics', to: 'final-review', type: 'no', label: 'all done' },
      { from: 'final-review', to: 'supersede' },
      { from: 'supersede', to: 'signoff' },
      { from: 'signoff', to: 'end' },
      { from: 'end', to: 'next', type: 'transition' },
    ]
  },
  'skill-planning': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry: technical-planning skill receives specification and context.' },
      { id: 'resume', label: 'Existing plan?', shape: 'diamond', w: 110, h: 110, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Step 0: Check if plan index file exists at docs/workflow/planning/{topic}.md.' },
      { id: 'resume-choice', label: 'Continue / Restart?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'User chooses: continue from previous position or restart (deletes existing plan).' },
      { id: 'init', label: 'Initialize plan', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 1: Create plan index file. Choose output format.' },
      { id: 'load-existing', label: 'Load existing plan', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Continue: load existing plan and output format adapter.' },
      { id: 'principles', label: 'Load principles', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 2: Load planning-principles.md. Internalize constraints.' },
      { id: 'verify', label: 'Verify source material', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 3: Verify specification files exist. Check cross-cutting references are accessible.' },
      // Plan construction — Phase structure
      { id: 'define-phases', label: 'Define phases', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'planning-phase-designer', desc: 'Step 4: Invoke planning-phase-designer agent to design phase structure from specification. If phases already exist (resume), present for review instead.' },
      { id: 'approve-phases', label: 'ASK: Approve phases?', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Present phase structure. User: approve (y), provide feedback (re-invokes phase-designer agent), or navigate to a specific position.' },
      // Plan construction — Phase loop
      { id: 'next-phase', label: 'Phases remain?', shape: 'diamond', w: 130, h: 130, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if unprocessed phases remain. Iterates through each phase in order. User can navigate to any phase at approval gates.' },
      { id: 'define-tasks', label: 'A. Define tasks', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'planning-task-designer', desc: 'Step A: Invoke planning-task-designer agent to break current phase into tasks with edge cases. If task table exists (resume), present for review — user can approve or request changes (re-invokes agent).' },
      { id: 'approve-tasks', label: 'ASK: Approve task list?', w: 210, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Present task list for the phase. User: approve (y), provide feedback (re-invokes task-designer agent), or navigate.' },
      // Plan construction — Task loop
      { id: 'next-task', label: 'Tasks remain?', shape: 'diamond', w: 130, h: 130, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check for pending tasks in current phase. Already-authored tasks are skipped with a brief summary. When all tasks are authored, phase is complete.' },
      { id: 'author-task', label: 'B. Author task', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'planning-task-author', desc: 'Step B: Invoke planning-task-author agent to write full task detail (problem, solution, outcome, acceptance criteria, tests). Parallel authoring of independent tasks is allowed after the first task in a phase is approved.' },
      { id: 'approve-task', label: 'ASK: Approve task?', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Present authored task exactly as it will be written. User: approve (y — logs verbatim), provide feedback (re-invokes task-author agent), or navigate.' },
      { id: 'log-task', label: 'Log task + commit', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Write task to output format adapter, mark as authored in plan index, advance planning position, commit.' },
      // Post construction
      { id: 'analyze-graph', label: 'Analyze task graph', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'planning-dependency-grapher', desc: 'Step 5: Invoke planning-dependency-grapher agent. Clears existing graph, analyzes all tasks, assigns priorities, detects cycles. User approves or requests changes (re-invokes agent).' },
      { id: 'deps', label: 'Resolve ext deps', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 6: Document external dependencies from specification. Match to tasks in other plans if possible. Reverse-check other plans for deps on this topic. Mark unresolved for /link-dependencies.' },
      // Review — Traceability
      { id: 'traceability', label: 'Traceability review', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 7a: Two-direction check — Spec→Plan (completeness: every decision, requirement, edge case covered) and Plan→Spec (fidelity: anti-hallucination, everything traces back to spec). Creates tracking file.' },
      { id: 'trace-finding', label: 'ASK: Approve fix?', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Process findings one at a time. Present finding + proposed fix (update/add/remove task, add/remove phase). User: approve (y — applies verbatim), skip, or request changes. Commits after each.' },
      // Review — Integrity
      { id: 'integrity', label: 'Integrity review', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 7b: Standalone plan quality — task template compliance, vertical slicing, phase structure, dependency ordering, task self-containment, granularity, acceptance criteria quality, external dependencies.' },
      { id: 'integ-finding', label: 'ASK: Approve fix?', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Process findings one at a time (Critical/Important/Minor). Present finding + proposed fix. User: approve (y — applies verbatim), skip, or request changes. Commits after each. Tracking file deleted when complete.' },
      // Conclusion
      { id: 'conclude', label: 'Conclude plan', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 8: Set status: concluded. Checkpoint: all tasks must be authored before concluding.' },
      { id: 'end', label: 'planning/{topic}.md', shape: 'pill', w: 150, h: 40, color: 'var(--planning)', bg: 'var(--planning-bg)', desc: 'Output: Plan index + authored tasks in chosen output format.' },
      { id: 'next', label: 'Invoke /start-implementation', desc: 'Navigate to the implementation command to execute the plan via strict TDD.', w: 215, h: 44, color: 'var(--next)', bg: 'var(--next-bg)', skillLink: 'implementation' },
    ],
    connections: [
      // Setup flow
      { from: 'start', to: 'resume' },
      { from: 'resume', to: 'resume-choice', type: 'yes', label: 'exists' },
      { from: 'resume', to: 'init', type: 'no', label: 'new' },
      { from: 'resume-choice', to: 'load-existing', label: 'continue' },
      { from: 'resume-choice', to: 'init', label: 'restart' },
      { from: 'load-existing', to: 'principles' },
      { from: 'init', to: 'principles' },
      { from: 'principles', to: 'verify' },
      // Plan construction — phase structure
      { from: 'verify', to: 'define-phases' },
      { from: 'define-phases', to: 'approve-phases' },
      { from: 'approve-phases', to: 'define-phases', type: 'backloop', label: 'revise' },
      { from: 'approve-phases', to: 'next-phase', type: 'yes', label: 'approved', weight: 2 },
      // Plan construction — phase loop
      { from: 'next-phase', to: 'define-tasks', type: 'yes', label: 'has phase', weight: 2 },
      { from: 'next-phase', to: 'analyze-graph', type: 'no', label: 'all done' },
      { from: 'define-tasks', to: 'approve-tasks' },
      { from: 'approve-tasks', to: 'define-tasks', type: 'backloop', label: 'revise' },
      { from: 'approve-tasks', to: 'next-task', type: 'yes', label: 'approved', weight: 2, toPort: 'upper-left' },
      // Plan construction — task loop
      { from: 'next-task', to: 'author-task', type: 'yes', label: 'pending', weight: 2, port: 'lower-left' },
      { from: 'next-task', to: 'next-phase', type: 'backloop', label: 'phase done', port: 'upper-right' },
      { from: 'author-task', to: 'approve-task' },
      { from: 'approve-task', to: 'author-task', type: 'backloop', label: 'revise' },
      { from: 'approve-task', to: 'log-task', type: 'yes', label: 'approved', weight: 2 },
      { from: 'log-task', to: 'next-task', type: 'backloop', label: 'next task', toPort: 'lower-right' },
      // Post construction
      { from: 'analyze-graph', to: 'deps' },
      // Review — traceability
      { from: 'deps', to: 'traceability' },
      { from: 'traceability', to: 'trace-finding' },
      { from: 'trace-finding', to: 'traceability', type: 'backloop', label: 'more findings' },
      { from: 'trace-finding', to: 'integrity', label: 'all processed' },
      // Review — integrity
      { from: 'integrity', to: 'integ-finding' },
      { from: 'integ-finding', to: 'integrity', type: 'backloop', label: 'more findings' },
      { from: 'integ-finding', to: 'conclude', label: 'all processed' },
      // Conclusion
      { from: 'conclude', to: 'end' },
      { from: 'end', to: 'next', type: 'transition' },
    ]
  },
  'skill-implementation': {
    nodes: [
      // Orchestrator setup (Steps 1-5)
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry: technical-implementation skill receives plan, env info, and tracking state.' },
      { id: 'env-setup', label: '1. Environment setup', w: 195, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 1: Run setup commands from environment-setup.md. Sequential, exactly as written.' },
      { id: 'read-plan', label: '2. Read plan + adapter', w: 195, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 2: Load plan, read format field, load output format adapters (reading, updating, authoring).' },
      { id: 'init-track', label: '3. Init tracking file', w: 195, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Step 3: Create/resume docs/workflow/implementation/{topic}/tracking.md. Reset gate modes and cycles on fresh session.' },
      { id: 'skills-disc', label: '4. Project skills', w: 195, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 4: Scan .claude/skills/ for project-specific conventions. ASK user which to pass to agents.' },
      { id: 'linter-disc', label: '5. Linter discovery', w: 195, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Step 5: Identify project linters via linter-setup.md. ASK user to approve/modify/skip. Store commands in tracking file.' },
      // Task loop (Step 6) — Stages A-E
      { id: 'retrieve', label: 'A. Retrieve next task', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Task loop Stage A: Use plan adapter to get next available task. Normalise task content for agent invocation.' },
      { id: 'done-check', label: 'Tasks remain?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if any tasks remain. If none, exit loop.' },
      { id: 'executor', label: 'B. Invoke executor', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'implementation-task-executor', desc: 'Task loop Stage B: Dispatch executor agent with TDD workflow, code quality refs, spec, project skills, linter commands, and normalised task.' },
      { id: 'exec-result', label: 'Executor result?', shape: 'diamond', w: 130, h: 130, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Route on executor STATUS: complete → review, blocked/failed → present to user.' },
      { id: 'exec-blocked', label: 'Executor blocked', shape: 'stop', w: 180, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Present executor ISSUES to user. Options: retry (with comments), skip task, or stop implementation entirely.' },
      { id: 'reviewer', label: 'C. Invoke reviewer', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'implementation-task-reviewer', desc: 'Task loop Stage C: Dispatch reviewer agent (opus). Independent verification — 6 dimensions including codebase cohesion.' },
      { id: 'review-result', label: 'Reviewer verdict?', shape: 'diamond', w: 130, h: 130, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Route on VERDICT: approved → task gate, needs-changes → check fix_gate_mode.' },
      { id: 'fix-gate', label: 'fix_gate_mode?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check fix_gate_mode. Auto (attempts < 3) = re-invoke executor. Gated or attempts >= 3 = present to user.' },
      { id: 'review-changes', label: 'ASK: Fix analysis', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Present reviewer ISSUES with FIX/ALTERNATIVE/CONFIDENCE. Options: accept (y), auto-approve future (a), skip (s), or comment.' },
      { id: 'gate', label: 'D. Task gate', shape: 'diamond', w: 130, h: 130, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Task loop Stage D: Check task_gate_mode. Gated = present summary. Auto = announce and proceed.' },
      { id: 'gate-prompt', label: 'ASK: Approve task?', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Gated mode: Present task summary. Options: approve (y), switch to auto mode, or comment (triggers executor fix round).' },
      { id: 'commit', label: 'E. Update + commit', w: 200, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Task loop Stage E: Update task in plan (via adapter), mirror to tracking file, append context notes, commit.' },
      // Exit routing
      { id: 'exit-route', label: 'Early stop?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'If user chose stop during task loop, skip analysis and go to completion. Otherwise proceed to analysis.' },
      // Analysis loop (Step 7) — Stages A-F
      { id: 'a-cycle-gate', label: 'A. Cycle gate', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Analysis Stage A: Increment analysis_cycle. If > 3, warn user and ask whether to skip or proceed.' },
      { id: 'b-checkpoint', label: 'B. Git checkpoint', w: 195, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Analysis Stage B: Ensure clean working tree. Commit any uncommitted implementation files.' },
      { id: 'c-duplication', label: 'C. Duplication', w: 160, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'implementation-analysis-duplication', desc: 'Analysis agent: hunt for cross-file duplication, near-duplicate logic, extraction candidates.' },
      { id: 'c-standards', label: 'C. Standards', w: 160, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'implementation-analysis-standards', desc: 'Analysis agent: check spec conformance, project skill compliance, missing validations.' },
      { id: 'c-architecture', label: 'C. Architecture', w: 160, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'implementation-analysis-architecture', desc: 'Analysis agent: evaluate API surface, module structure, seam quality, over/under-engineering.' },
      { id: 'd-synthesizer', label: 'D. Synthesizer', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'implementation-analysis-synthesizer', desc: 'Analysis Stage D: Deduplicate, group, and normalize findings into tasks. Writes staging file.' },
      { id: 'd-result', label: 'Tasks proposed?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Route on synthesizer STATUS: tasks_proposed → approval gate, clean → completion.' },
      { id: 'e-approval', label: 'E. Approve tasks', w: 200, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Analysis Stage E: Present each proposed task one at a time. User approves, skips, or comments per task.' },
      { id: 'e-result', label: 'Any approved?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'If any tasks approved, create them in the plan. If all skipped, proceed to completion.' },
      { id: 'f-task-writer', label: 'F. Create plan tasks', w: 200, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', desc: 'Analysis Stage F: Invoke task-writer agent to create approved tasks in the plan as a new phase. Commit.', skillLink: 'implementation-analysis-task-writer' },
      // Completion (Step 8)
      { id: 'end', label: 'Implementation complete', shape: 'pill', w: 190, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Step 8: Set tracking status: completed. Final commit.' },
      { id: 'next', label: 'Invoke /start-review', desc: 'Navigate to the review command to validate implementation against the plan and specification.', w: 200, h: 44, color: 'var(--next)', bg: 'var(--next-bg)', skillLink: 'review' },
    ],
    connections: [
      // Setup flow (Steps 1-5)
      { from: 'start', to: 'env-setup' },
      { from: 'env-setup', to: 'read-plan' },
      { from: 'read-plan', to: 'init-track' },
      { from: 'init-track', to: 'skills-disc' },
      { from: 'skills-disc', to: 'linter-disc' },
      // Enter task loop (Step 6)
      { from: 'linter-disc', to: 'retrieve', type: 'transition' },
      { from: 'retrieve', to: 'done-check' },
      { from: 'done-check', to: 'executor', type: 'yes', label: 'has task', weight: 2 },
      { from: 'done-check', to: 'exit-route', type: 'no', label: 'none left' },
      // B: Executor
      { from: 'executor', to: 'exec-result' },
      { from: 'exec-result', to: 'reviewer', type: 'yes', label: 'complete', weight: 2 },
      { from: 'exec-result', to: 'exec-blocked', type: 'no', label: 'blocked' },
      { from: 'exec-blocked', to: 'executor', type: 'backloop', label: 'retry' },
      { from: 'exec-blocked', to: 'commit', label: 'skip' },
      // C: Reviewer
      { from: 'reviewer', to: 'review-result' },
      { from: 'review-result', to: 'gate', type: 'yes', label: 'approved', weight: 2, toPort: 'upper-right' },
      { from: 'review-result', to: 'fix-gate', type: 'no', label: 'needs changes' },
      { from: 'fix-gate', to: 'executor', label: 'auto', type: 'backloop' },
      { from: 'fix-gate', to: 'review-changes', label: 'gated' },
      { from: 'review-changes', to: 'executor', type: 'backloop', label: 'fix' },
      { from: 'review-changes', to: 'gate', label: 'skip', toPort: 'upper-left' },
      // D: Task gate
      { from: 'gate', to: 'gate-prompt', label: 'gated' },
      { from: 'gate', to: 'commit', label: 'auto' },
      { from: 'gate-prompt', to: 'commit', type: 'yes', label: 'approve' },
      { from: 'gate-prompt', to: 'executor', type: 'backloop', label: 'comment' },
      // E: Commit and loop back
      { from: 'commit', to: 'retrieve', type: 'backloop', label: 'next task' },
      // Exit routing
      { from: 'exit-route', to: 'end', type: 'no', label: 'early stop' },
      { from: 'exit-route', to: 'a-cycle-gate', type: 'yes', label: 'normal', weight: 2 },
      // Analysis loop (Step 7) — Stages A-F
      { from: 'a-cycle-gate', to: 'end', type: 'no', label: 'skip' },
      { from: 'a-cycle-gate', to: 'b-checkpoint', type: 'yes', label: 'proceed', weight: 2 },
      { from: 'b-checkpoint', to: 'c-duplication' },
      { from: 'b-checkpoint', to: 'c-standards' },
      { from: 'b-checkpoint', to: 'c-architecture' },
      { from: 'c-duplication', to: 'd-synthesizer' },
      { from: 'c-standards', to: 'd-synthesizer' },
      { from: 'c-architecture', to: 'd-synthesizer' },
      { from: 'd-synthesizer', to: 'd-result' },
      { from: 'd-result', to: 'end', type: 'no', label: 'clean' },
      { from: 'd-result', to: 'e-approval', type: 'yes', label: 'tasks', weight: 2 },
      { from: 'e-approval', to: 'e-result' },
      { from: 'e-result', to: 'end', type: 'no', label: 'all skipped' },
      { from: 'e-result', to: 'f-task-writer', type: 'yes', label: 'approved', weight: 2 },
      { from: 'f-task-writer', to: 'retrieve', type: 'backloop', label: 'new tasks → Step 6' },
      // Next phase
      { from: 'end', to: 'next', type: 'transition' },
    ]
  },
  'skill-review': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry: technical-review skill receives plan, optional spec, and scope.' },
      { id: 'validate', label: 'Validate inputs', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Verify plan is available. Specification is optional but helpful.' },
      { id: 'read-plan', label: 'Read plan', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Read the plan — all phases, tasks, and acceptance criteria.' },
      { id: 'read-spec', label: 'Read specification', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'If available, read specification for design context.' },
      { id: 'extract', label: 'Extract ALL tasks', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'List every task from every phase. Verify all, not a sample.' },
      { id: 'spawn', label: 'Spawn task verifiers', w: 180, h: 44, color: 'var(--agent)', bg: 'var(--agent-bg)', skillLink: 'review-task-verifier', desc: 'Launch parallel review-task-verifier subagents (haiku). One per task.' },
      { id: 'v1', label: 'Verify task 1', w: 140, h: 44, color: 'var(--action)', bg: 'rgba(56,189,248,0.08)', desc: 'Check: implementation, acceptance criteria, tests, code quality.' },
      { id: 'v2', label: 'Verify task 2', w: 140, h: 44, color: 'var(--action)', bg: 'rgba(56,189,248,0.08)', desc: 'Same checks, different task. Runs in parallel.' },
      { id: 'vn', label: 'Verify task N', w: 140, h: 44, color: 'var(--action)', bg: 'rgba(56,189,248,0.08)', desc: 'One per task. All run simultaneously.' },
      { id: 'aggregate', label: 'Aggregate findings', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Collect verifier results. Merge into structured review.' },
      { id: 'conventions', label: 'Check conventions', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Check project skills for conventions. Apply SOLID, DRY, etc.' },
      { id: 'produce', label: 'Produce review', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Generate structured review: per-task verdicts, overall verdict.' },
      { id: 'end', label: 'approve / changes', shape: 'pill', w: 150, h: 40, color: 'var(--review)', bg: 'var(--review-bg)', desc: 'Output: Approve, request changes, or comments. Does NOT fix code.' },
    ],
    connections: [
      { from: 'start', to: 'validate' },
      { from: 'validate', to: 'read-plan' },
      { from: 'read-plan', to: 'read-spec' },
      { from: 'read-spec', to: 'extract' },
      { from: 'extract', to: 'spawn' },
      { from: 'spawn', to: 'v1' },
      { from: 'spawn', to: 'v2' },
      { from: 'spawn', to: 'vn' },
      { from: 'v1', to: 'aggregate' },
      { from: 'v2', to: 'aggregate' },
      { from: 'vn', to: 'aggregate' },
      { from: 'aggregate', to: 'conventions' },
      { from: 'conventions', to: 'produce' },
      { from: 'produce', to: 'end' },
    ]
  },
  'status': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /status.' },
      { id: 'migrate', label: 'Run /migrate', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Step 0: Run migrations to keep workflow files in sync.' },
      { id: 'gate-migrate', label: 'Files updated?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if migration scripts modified any workflow files.' },
      { id: 'wait-review', label: 'STOP: Review changes', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Migration updated files. Pause for user to review changes before continuing.' },
      { id: 'scan', label: 'Scan workflow directories', w: 200, h: 44, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Scan docs/workflow/ subdirectories for research, discussion, specification, planning files.' },
      { id: 'present', label: 'Present status table', w: 180, h: 44, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Display a table organized by topic showing progress across all 6 phases.' },
      { id: 'suggest', label: 'Suggest next steps', w: 180, h: 44, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Recommend which workflow command to run next based on current state.' },
      { id: 'end', label: 'Status output', shape: 'pill', w: 150, h: 40, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Final status overview presented to the user.' },
    ],
    connections: [
      { from: 'start', to: 'migrate' },
      { from: 'migrate', to: 'gate-migrate' },
      { from: 'gate-migrate', to: 'scan', type: 'no', label: 'no' },
      { from: 'gate-migrate', to: 'wait-review', type: 'yes', label: 'yes' },
      { from: 'wait-review', to: 'scan' },
      { from: 'scan', to: 'present' },
      { from: 'present', to: 'suggest' },
      { from: 'suggest', to: 'end' },
    ]
  },
  'view-plan': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /view-plan.' },
      { id: 'gate-plans', label: 'Plans exist?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if any plan files exist in docs/workflow/planning/.' },
      { id: 'stop', label: 'STOP: No plans', shape: 'stop', w: 150, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Terminal: No plans found. Run /start-planning first.' },
      { id: 'count', label: 'Single plan?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if there is exactly one plan or multiple.' },
      { id: 'auto', label: 'Auto-select single', w: 180, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Only one plan exists. Auto-select it.' },
      { id: 'ask', label: 'ASK: Which plan?', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Multiple plans found. Ask user which plan to view.' },
      { id: 'read-index', label: 'Read plan index', w: 180, h: 44, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Read the plan frontmatter and index to understand structure and format.' },
      { id: 'load-format', label: 'Load format reference', w: 180, h: 44, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Load the output format reference file based on the plan format field.' },
      { id: 'read-content', label: 'Read plan content', w: 180, h: 44, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Follow format reading instructions to read plan phases, tasks, and status.' },
      { id: 'present', label: 'Present summary', w: 180, h: 44, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Display plan summary with phases, tasks, progress, and dependencies.' },
      { id: 'end', label: 'Plan summary', shape: 'pill', w: 150, h: 40, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'Final plan summary presented to the user.' },
    ],
    connections: [
      { from: 'start', to: 'gate-plans' },
      { from: 'gate-plans', to: 'count', type: 'yes', label: 'exist', weight: 2 },
      { from: 'gate-plans', to: 'stop', type: 'no', label: 'none' },
      { from: 'count', to: 'auto', label: 'one' },
      { from: 'count', to: 'ask', label: 'multi' },
      { from: 'auto', to: 'read-index' },
      { from: 'ask', to: 'read-index' },
      { from: 'read-index', to: 'load-format' },
      { from: 'load-format', to: 'read-content' },
      { from: 'read-content', to: 'present' },
      { from: 'present', to: 'end' },
    ]
  },
  'migrate': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Entry point for /migrate.' },
      { id: 'run', label: 'Run migrate.sh', w: 180, h: 44, color: 'var(--accent)', bg: 'rgba(108,138,255,0.12)', desc: 'Execute skills/migrate/scripts/migrate.sh — runs all numbered migration scripts in order. Idempotent.' },
      { id: 'updated', label: 'Files updated?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if any migration scripts modified workflow files.' },
      { id: 'show-changes', label: 'Show changes + review', w: 180, h: 44, color: 'var(--ask)', bg: 'var(--ask-bg)', desc: 'Display changed files and wait for user to review via git diff.' },
      { id: 'end-updated', label: 'Changes applied', shape: 'pill', w: 150, h: 40, color: 'var(--discovery)', bg: 'var(--discovery-bg)', desc: 'Migration complete — files were updated.' },
      { id: 'end-clean', label: 'All up to date', shape: 'pill', w: 150, h: 40, color: '#94a3b8', bg: 'rgba(148,163,184,0.12)', desc: 'No changes needed — all workflow files already in sync.' },
    ],
    connections: [
      { from: 'start', to: 'run' },
      { from: 'run', to: 'updated' },
      { from: 'updated', to: 'end-clean', type: 'no', label: 'no' },
      { from: 'updated', to: 'show-changes', type: 'yes', label: 'yes' },
      { from: 'show-changes', to: 'end-updated' },
    ]
  },
  // ── Agent Flowcharts ──
  'planning-phase-designer': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-planning skill during plan construction.' },
      { id: 'read-refs', label: 'Read spec ingestion', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read specification ingestion protocol and full spec. Also reads cross-cutting specs if referenced.' },
      { id: 'read-principles', label: 'Read design principles', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read phase design principles and task design principles reference files.' },
      { id: 'design', label: 'Design phases', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Design implementation phase structure. Define goals, acceptance criteria, and sequencing.' },
      { id: 'amend', label: 'Amendment?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if prior output + feedback exists (amendment round). If so, revise instead of starting fresh.' },
      { id: 'revise', label: 'Revise phases', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Read prior output and feedback, then revise the phase design accordingly.' },
      { id: 'end', label: 'Phase structure', shape: 'pill', w: 180, h: 40, color: 'var(--planning)', bg: 'var(--planning-bg)', desc: 'Output: human-readable phase summary with goals and acceptance criteria.' },
    ],
    connections: [
      { from: 'start', to: 'read-refs' },
      { from: 'read-refs', to: 'read-principles' },
      { from: 'read-principles', to: 'amend' },
      { from: 'amend', to: 'revise', type: 'yes', label: 'yes' },
      { from: 'amend', to: 'design', type: 'no', label: 'no', weight: 2 },
      { from: 'revise', to: 'end' },
      { from: 'design', to: 'end' },
    ]
  },
  'planning-task-designer': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-planning skill during plan construction.' },
      { id: 'read-refs', label: 'Read spec ingestion', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read specification ingestion protocol, full spec, cross-cutting specs, and approved phases.' },
      { id: 'read-principles', label: 'Read task principles', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read task design principles reference file.' },
      { id: 'design', label: 'Design task list', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Break target phase into individual tasks with edge cases for each.' },
      { id: 'amend', label: 'Amendment?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if prior output + feedback exists (amendment round). If so, revise instead of starting fresh.' },
      { id: 'revise', label: 'Revise tasks', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Read prior output and feedback, then revise the task list accordingly.' },
      { id: 'end', label: 'Task list', shape: 'pill', w: 180, h: 40, color: 'var(--planning)', bg: 'var(--planning-bg)', desc: 'Output: task table with IDs, names, edge cases, and status.' },
    ],
    connections: [
      { from: 'start', to: 'read-refs' },
      { from: 'read-refs', to: 'read-principles' },
      { from: 'read-principles', to: 'amend' },
      { from: 'amend', to: 'revise', type: 'yes', label: 'yes' },
      { from: 'amend', to: 'design', type: 'no', label: 'no', weight: 2 },
      { from: 'revise', to: 'end' },
      { from: 'design', to: 'end' },
    ]
  },
  'planning-task-author': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-planning skill during plan construction.' },
      { id: 'read-refs', label: 'Read spec ingestion', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read specification ingestion protocol, full spec, and cross-cutting specs.' },
      { id: 'read-template', label: 'Read task template', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read task design template, phases, and task list for context.' },
      { id: 'read-format', label: 'Read format adapter', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Load the output format adapter (authoring.md) for the plan\'s chosen format.' },
      { id: 'author', label: 'Author task detail', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write complete task in output format structure: problem, solution, outcome, acceptance criteria, tests, context.' },
      { id: 'amend', label: 'Amendment?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if prior output + feedback exists (amendment round). If so, revise instead of starting fresh.' },
      { id: 'revise', label: 'Revise task', w: 180, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Read prior output and feedback, then revise the authored task accordingly.' },
      { id: 'end', label: 'Authored task', shape: 'pill', w: 180, h: 40, color: 'var(--planning)', bg: 'var(--planning-bg)', desc: 'Output: complete task detail in exact output format adapter structure.' },
    ],
    connections: [
      { from: 'start', to: 'read-refs' },
      { from: 'read-refs', to: 'read-template' },
      { from: 'read-template', to: 'read-format' },
      { from: 'read-format', to: 'amend' },
      { from: 'amend', to: 'revise', type: 'yes', label: 'yes' },
      { from: 'amend', to: 'author', type: 'no', label: 'no', weight: 2 },
      { from: 'revise', to: 'end' },
      { from: 'author', to: 'end' },
    ]
  },
  'planning-dependency-grapher': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-planning skill after plan construction.' },
      { id: 'read-format', label: 'Read format refs', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read reading.md and graph.md format adapter references.' },
      { id: 'read-index', label: 'Read plan index', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read the plan index file to understand plan structure.' },
      { id: 'list-tasks', label: 'List authored tasks', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Enumerate all authored task files from the plan.' },
      { id: 'clear', label: 'Clear existing graph', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Clear any existing dependency graph data before re-analysis.' },
      { id: 'analyze', label: 'Analyze dependencies', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Read every task. Extract produces/requires. Match produces→requires across all tasks. Identify data, capability, and infrastructure dependencies.' },
      { id: 'priorities', label: 'Assign priorities', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Classify tasks as bottleneck, foundation, or leaf based on dependency analysis.' },
      { id: 'cycles', label: 'Cycles detected?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if the dependency graph contains circular dependencies.' },
      { id: 'stop-cycles', label: 'STOP: Report cycles', shape: 'stop', w: 180, h: 40, color: 'var(--gate)', bg: 'var(--gate-bg)', desc: 'Cycles found — report cycle chains and do NOT apply changes.' },
      { id: 'apply', label: 'Apply graph changes', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write dependency and priority data back to tasks using the graph format adapter.' },
      { id: 'end', label: 'Dependency graph', shape: 'pill', w: 180, h: 40, color: 'var(--planning)', bg: 'var(--planning-bg)', desc: 'Output: structured summary with dependencies, priorities, and status.' },
    ],
    connections: [
      { from: 'start', to: 'read-format' },
      { from: 'read-format', to: 'read-index' },
      { from: 'read-index', to: 'list-tasks' },
      { from: 'list-tasks', to: 'clear' },
      { from: 'clear', to: 'analyze' },
      { from: 'analyze', to: 'priorities' },
      { from: 'priorities', to: 'cycles' },
      { from: 'cycles', to: 'stop-cycles', type: 'yes', label: 'yes' },
      { from: 'cycles', to: 'apply', type: 'no', label: 'no', weight: 2 },
      { from: 'apply', to: 'end' },
    ]
  },
  'implementation-task-executor': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-implementation skill for a single task.' },
      { id: 'read-refs', label: 'Read TDD + quality refs', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read TDD workflow reference and code quality standards. Read project skills and specification.' },
      { id: 'explore', label: 'Explore codebase', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Explore the codebase to understand existing patterns, conventions, and relevant code.' },
      { id: 'write-test', label: 'RED: Write failing test', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'TDD red phase: write a test for the next acceptance criterion. Test must fail for the right reason.' },
      { id: 'implement', label: 'GREEN: Implement', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'TDD green phase: write complete, functional implementation to make the test pass.' },
      { id: 'refactor', label: 'REFACTOR', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'TDD refactor phase: remove duplication, improve naming, extract methods. Run tests after — if they fail, undo.' },
      { id: 'lint', label: 'LINT', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Run configured linter commands (if any). Fix issues, re-run to confirm clean, re-run tests. Revert if tests break.' },
      { id: 'more', label: 'More criteria?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if there are more acceptance criteria / test cases to implement.' },
      { id: 'report', label: 'Build report', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Compile structured completion report: status, files changed, tests written, test results.' },
      { id: 'end', label: 'STATUS report', shape: 'pill', w: 180, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Output: structured report (complete/blocked/failed) with files, tests, and issues.' },
    ],
    connections: [
      { from: 'start', to: 'read-refs' },
      { from: 'read-refs', to: 'explore' },
      { from: 'explore', to: 'write-test' },
      { from: 'write-test', to: 'implement' },
      { from: 'implement', to: 'refactor' },
      { from: 'refactor', to: 'lint' },
      { from: 'lint', to: 'more' },
      { from: 'more', to: 'write-test', type: 'backloop', label: 'yes', port: 'right' },
      { from: 'more', to: 'report', type: 'no', label: 'no', weight: 2 },
      { from: 'report', to: 'end' },
    ]
  },
  'implementation-task-reviewer': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-implementation skill after each task.' },
      { id: 'read-spec', label: 'Read specification', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read the specification to understand the broader requirement and constraints.' },
      { id: 'read-skills', label: 'Read project skills', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Load project skills to understand conventions and patterns.' },
      { id: 'read-context', label: 'Read integration context', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Load accumulated integration context from prior tasks for cohesion checking.' },
      { id: 'check-diff', label: 'Check unstaged changes', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Run git diff/status to identify all changed files from the executor.' },
      { id: 'read-files', label: 'Read changed files', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read the full content of all changed files for review.' },
      { id: 'evaluate', label: 'Evaluate 6 dimensions', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Evaluate: spec conformance, acceptance criteria, test adequacy, convention adherence, architectural quality, codebase cohesion.' },
      { id: 'verdict', label: 'Verdict?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Determine verdict: approved or needs-changes based on evaluation.' },
      { id: 'report', label: 'Build review + fix analysis', w: 210, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Compile structured review with file:line references. For needs-changes: include FIX/ALTERNATIVE/CONFIDENCE per issue.' },
      { id: 'end', label: 'VERDICT report', shape: 'pill', w: 180, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Output: structured verdict (approved/needs-changes) with issues, fix recommendations, and cohesion notes.' },
    ],
    connections: [
      { from: 'start', to: 'read-spec' },
      { from: 'read-spec', to: 'read-skills' },
      { from: 'read-skills', to: 'read-context' },
      { from: 'read-context', to: 'check-diff' },
      { from: 'check-diff', to: 'read-files' },
      { from: 'read-files', to: 'evaluate' },
      { from: 'evaluate', to: 'verdict' },
      { from: 'verdict', to: 'report' },
      { from: 'report', to: 'end' },
    ]
  },
  'implementation-analysis-duplication': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked in parallel by technical-implementation during analysis cycle.' },
      { id: 'read-quality', label: 'Read code quality', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read code-quality.md to understand quality standards.' },
      { id: 'read-skills', label: 'Read project skills', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read project skills for framework conventions and existing patterns.' },
      { id: 'read-spec', label: 'Read specification', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read specification to understand design intent.' },
      { id: 'read-files', label: 'Read implementation files', w: 210, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read all implementation files to build a full mental map of the codebase.' },
      { id: 'analyze', label: 'Analyze for duplication', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Compare patterns across files. Find near-duplicates, extraction candidates, copy-paste drift.' },
      { id: 'write', label: 'Write findings file', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write findings to {topic}/analysis-duplication.md with severity, files, description, recommendation.' },
      { id: 'end', label: 'STATUS report', shape: 'pill', w: 180, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Output: findings | clean, with count and summary.' },
    ],
    connections: [
      { from: 'start', to: 'read-quality' },
      { from: 'read-quality', to: 'read-skills' },
      { from: 'read-skills', to: 'read-spec' },
      { from: 'read-spec', to: 'read-files' },
      { from: 'read-files', to: 'analyze' },
      { from: 'analyze', to: 'write' },
      { from: 'write', to: 'end' },
    ]
  },
  'implementation-analysis-standards': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked in parallel by technical-implementation during analysis cycle.' },
      { id: 'read-quality', label: 'Read code quality', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read code-quality.md to understand quality standards.' },
      { id: 'read-skills', label: 'Read project skills', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read project skills — MUST DO/MUST NOT DO rules are primary targets.' },
      { id: 'read-spec', label: 'Read specification', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read specification — the specification advocate\'s primary reference.' },
      { id: 'read-files', label: 'Read implementation files', w: 210, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read all implementation files to check conformance.' },
      { id: 'analyze', label: 'Analyze for standards drift', w: 210, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Check spec conformance, project skill compliance, spec-vs-convention conflicts, missing validations.' },
      { id: 'write', label: 'Write findings file', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write findings to {topic}/analysis-standards.md with severity, files, description, recommendation.' },
      { id: 'end', label: 'STATUS report', shape: 'pill', w: 180, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Output: findings | clean, with count and summary.' },
    ],
    connections: [
      { from: 'start', to: 'read-quality' },
      { from: 'read-quality', to: 'read-skills' },
      { from: 'read-skills', to: 'read-spec' },
      { from: 'read-spec', to: 'read-files' },
      { from: 'read-files', to: 'analyze' },
      { from: 'analyze', to: 'write' },
      { from: 'write', to: 'end' },
    ]
  },
  'implementation-analysis-architecture': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked in parallel by technical-implementation during analysis cycle.' },
      { id: 'read-quality', label: 'Read code quality', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read code-quality.md to understand quality standards.' },
      { id: 'read-skills', label: 'Read project skills', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read project skills for architectural patterns and conventions.' },
      { id: 'read-spec', label: 'Read specification', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read specification for intended architecture and design decisions.' },
      { id: 'read-files', label: 'Read implementation files', w: 210, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read all implementation files as an architect who didn\'t write the code.' },
      { id: 'analyze', label: 'Analyze architecture', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Evaluate API surface quality, module structure, seam quality between task boundaries, over/under-engineering.' },
      { id: 'write', label: 'Write findings file', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write findings to {topic}/analysis-architecture.md with severity, files, description, recommendation.' },
      { id: 'end', label: 'STATUS report', shape: 'pill', w: 180, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Output: findings | clean, with count and summary.' },
    ],
    connections: [
      { from: 'start', to: 'read-quality' },
      { from: 'read-quality', to: 'read-skills' },
      { from: 'read-skills', to: 'read-spec' },
      { from: 'read-spec', to: 'read-files' },
      { from: 'read-files', to: 'analyze' },
      { from: 'analyze', to: 'write' },
      { from: 'write', to: 'end' },
    ]
  },
  'implementation-analysis-synthesizer': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-implementation after all 3 analysis agents return.' },
      { id: 'read-findings', label: 'Read all findings files', w: 210, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Locate and read analysis-duplication.md, analysis-standards.md, analysis-architecture.md from the topic directory.' },
      { id: 'dedup', label: 'Deduplicate findings', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Same issue from multiple agents → one finding, noting all sources.' },
      { id: 'group', label: 'Group related findings', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Multiple findings about the same pattern become one task (e.g., 3 duplication findings = 1 extract helper task).' },
      { id: 'filter', label: 'Filter by severity', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Discard low-severity unless they cluster. Never discard high-severity.' },
      { id: 'normalize', label: 'Normalize into tasks', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Convert each group into a task using canonical template: Problem/Solution/Outcome/Do/AC/Tests.' },
      { id: 'write-report', label: 'Write analysis report', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write summary report to {topic}/analysis-report.md with discarded findings.' },
      { id: 'has-tasks', label: 'Tasks to propose?', shape: 'diamond', w: 120, h: 120, color: 'var(--routing)', bg: 'var(--routing-bg)', desc: 'Check if any actionable tasks remain after filtering.' },
      { id: 'write-staging', label: 'Write staging file', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Write tasks to {topic}/analysis-tasks.md with status: pending for each task.' },
      { id: 'end', label: 'STATUS report', shape: 'pill', w: 180, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Output: tasks_proposed (with count) or clean.' },
    ],
    connections: [
      { from: 'start', to: 'read-findings' },
      { from: 'read-findings', to: 'dedup' },
      { from: 'dedup', to: 'group' },
      { from: 'group', to: 'filter' },
      { from: 'filter', to: 'normalize' },
      { from: 'normalize', to: 'write-report' },
      { from: 'write-report', to: 'has-tasks' },
      { from: 'has-tasks', to: 'end', type: 'no', label: 'clean' },
      { from: 'has-tasks', to: 'write-staging', type: 'yes', label: 'yes', weight: 2 },
      { from: 'write-staging', to: 'end' },
    ]
  },
  'implementation-analysis-task-writer': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Invoked by technical-implementation after user approves analysis tasks.' },
      { id: 'read-staging', label: 'Read staging file', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Extract all tasks with status: approved from the staging file.' },
      { id: 'read-plan', label: 'Read plan (via adapter)', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Use reading adapter to determine max existing phase number.' },
      { id: 'calc-phase', label: 'Calculate next phase', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Next phase = max existing phase + 1.' },
      { id: 'read-authoring', label: 'Read authoring adapter', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Understand how to create tasks in this plan format.' },
      { id: 'create', label: 'Create tasks in plan', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Follow authoring adapter instructions to create each approved task. No content modifications.' },
      { id: 'end', label: 'STATUS report', shape: 'pill', w: 180, h: 40, color: 'var(--implementation)', bg: 'var(--implementation-bg)', desc: 'Output: complete, with tasks created count and phase number.' },
    ],
    connections: [
      { from: 'start', to: 'read-staging' },
      { from: 'read-staging', to: 'read-plan' },
      { from: 'read-plan', to: 'calc-phase' },
      { from: 'calc-phase', to: 'read-authoring' },
      { from: 'read-authoring', to: 'create' },
      { from: 'create', to: 'end' },
    ]
  },
  'review-task-verifier': {
    nodes: [
      { id: 'start', label: 'START', shape: 'pill', w: 150, h: 40, color: 'var(--accent)', bg: 'rgba(108,138,255,0.15)', desc: 'Agent entry point. Spawned in parallel by technical-review skill (one per task).' },
      { id: 'read-task', label: 'Understand task', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Read the task: what it does, acceptance criteria, and expected tests.' },
      { id: 'load-spec', label: 'Load spec context', w: 200, h: 44, color: 'var(--text-dim)', bg: 'var(--surface2)', desc: 'Load the broader specification context: requirements, constraints, edge cases.' },
      { id: 'verify-impl', label: 'Verify implementation', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Check: implementation exists, matches acceptance criteria, aligns with spec.' },
      { id: 'verify-tests', label: 'Verify tests', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Check: tests are adequate (not over/under), edge cases covered, tests pass.' },
      { id: 'check-quality', label: 'Check code quality', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Check conventions, SOLID, DRY, complexity, idioms, readability, security, performance.' },
      { id: 'compile', label: 'Compile findings', w: 200, h: 44, color: 'var(--action)', bg: 'var(--action-bg)', desc: 'Aggregate results into structured finding with blocking issues and non-blocking notes.' },
      { id: 'end', label: 'Task finding', shape: 'pill', w: 180, h: 40, color: 'var(--review)', bg: 'var(--review-bg)', desc: 'Output: structured finding (complete/incomplete/issues) with implementation, tests, and quality assessment.' },
    ],
    connections: [
      { from: 'start', to: 'read-task' },
      { from: 'read-task', to: 'load-spec' },
      { from: 'load-spec', to: 'verify-impl' },
      { from: 'verify-impl', to: 'verify-tests' },
      { from: 'verify-tests', to: 'check-quality' },
      { from: 'check-quality', to: 'compile' },
      { from: 'compile', to: 'end' },
    ]
  }
};

// ── Next-phase navigation mapping for skill flowcharts ──
const SKILL_NEXT_PHASE = {
  'skill-research':       { label: 'Invoke /start-discussion',       target: 'discussion',      color: 'var(--next)', bg: 'var(--next-bg)' },
  'skill-discussion':     { label: 'Invoke /start-specification',    target: 'specification',   color: 'var(--next)', bg: 'var(--next-bg)' },
  'skill-specification':  { label: 'Invoke /start-planning',         target: 'planning',        color: 'var(--next)', bg: 'var(--next-bg)' },
  'skill-planning':       { label: 'Invoke /start-implementation',   target: 'implementation',  color: 'var(--next)', bg: 'var(--next-bg)' },
  'skill-implementation': { label: 'Invoke /start-review',           target: 'review',          color: 'var(--next)', bg: 'var(--next-bg)' },
};

// Info bar descriptions — richer content per flowchart
const FLOWCHART_DESCS = {
  research: {
    summary: 'Explore ideas, feasibility, and validate concepts across technical, business, and market domains.',
    body: `<p>The simplest command — no discovery script, no prerequisites, no cache. Gathers context through 4 sequential questions (seed idea, existing knowledge, starting direction, constraints) then hands off to the <strong>technical-research</strong> skill.</p>
<p>The skill acts as a research partner, looping through <strong>Ask → Discuss → Document → Commit</strong>. Output starts as a single file and splits as themes emerge. Research never formally "concludes" — it feeds into discussion when ready.</p>`,
    meta: { output: 'docs/workflow/research/', skill: 'technical-research', complexity: 'Simple' }
  },
  discussion: {
    summary: 'Capture architecture decisions, debates, edge cases, and rationale through structured dialogue.',
    body: `<p>Moderate complexity. A discovery script scans research files, existing discussions, and cache, then classifies the scenario: <strong>fresh</strong>, <strong>research_only</strong>, <strong>discussions_only</strong>, or <strong>research_and_discussions</strong>.</p>
<p>Research analysis is <strong>cache-aware</strong> — checksums detect stale analysis. The options menu adapts based on what exists (2–4 options). After user selection, context is gathered and the <strong>technical-discussion</strong> skill runs a loop: <strong>Engage → Capture decisions → Document → Commit</strong> until the discussion is concluded.</p>`,
    meta: { output: 'docs/workflow/discussion/{topic}.md', skill: 'technical-discussion', discovery: 'discovery-for-discussion.sh', cache: 'research-analysis.md' }
  },
  specification: {
    summary: 'Analyse discussion coupling, group into features, and build validated specifications.',
    body: `<p>The most complex command. Two prerequisite gates (discussions must exist and be concluded), a 6-condition routing matrix based on discussion count, existing specs, and cache state, plus 5 grouping options with a refresh loop.</p>
<p>The coupling engine reads all concluded discussions and analyses <strong>data, behavioural, and conceptual coupling</strong> to recommend feature groupings. The <strong>technical-specification</strong> skill is collaborative — it extracts, filters hallucinations, enriches gaps, presents for approval, and waits for explicit sign-off before writing.</p>`,
    meta: { output: 'docs/workflow/specification/{topic}.md', skill: 'technical-specification', discovery: 'discovery-for-specification.sh', cache: 'discussion-consolidation-analysis.md' }
  },
  planning: {
    summary: 'Transform specifications into phased implementation plans with tasks and acceptance criteria.',
    body: `<p>Discovery classifies into 3 scenarios: <strong>no_specs</strong>, <strong>nothing_actionable</strong>, or <strong>has_options</strong>. After selection, a plan-state check routes new plans through context gathering and cross-cutting spec surfacing, while existing plans skip straight to the skill.</p>
<p>The <strong>technical-planning</strong> skill runs a structured process with three nested loops. <strong>Plan construction</strong> is the core: the <strong>planning-phase-designer</strong> agent designs the phase structure (user approval gate with revision loop), then for each phase the <strong>planning-task-designer</strong> agent breaks it into tasks (approval gate), then for each task the <strong>planning-task-author</strong> agent writes full detail (approval gate, logged on approval). After construction, the <strong>planning-dependency-grapher</strong> agent analyzes the task graph for dependencies and cycles. Finally, a two-part <strong>plan review</strong> — traceability (spec↔plan completeness and anti-hallucination) then integrity (structural quality) — processes findings one at a time with per-finding approval gates.</p>`,
    meta: { output: 'docs/workflow/planning/{topic}.md', skill: 'technical-planning', discovery: 'discovery-for-planning.sh' }
  },
  implementation: {
    summary: 'Discover plans, classify readiness, gate on dependencies, and hand off to agent-based implementation.',
    body: `<p>Discovery classifies plans into three sections: <strong>Implementable</strong> (▶ in-progress or + ready to start), <strong>Implemented</strong> (> completed), and <strong>Not implementable</strong> (· blocked deps or plan not concluded). Plan presentation includes an <strong>unblock escape hatch</strong> — users can mark blocked deps as externally satisfied without leaving the selection step. Two gates follow: <strong>external dependencies</strong> (confirmation) and <strong>environment setup</strong> (info gathering only, does not execute setup).</p>
<p>Hands off to the <strong>technical-implementation</strong> skill, which dispatches executor and reviewer agents per task with a configurable approval gate (gated or auto mode). Scope selection is handled within the skill, not the command.</p>`,
    meta: { output: 'Code changes (tracked in plan)', skill: 'technical-implementation', discovery: 'discovery-for-implementation-and-review.sh' }
  },
  review: {
    summary: 'Validate completed implementation against plan tasks using parallel review-task-verifier subagents.',
    body: `<p>Shares a discovery script with implementation. After plan selection and scope identification, the <strong>technical-review</strong> skill reads the plan and spec, extracts all tasks, then spawns <strong>parallel review-task-verifier subagents</strong> (one per task, using Haiku model).</p>
<p>Each verifier checks: implementation exists, acceptance criteria met, test coverage adequate, and code quality acceptable. Results are aggregated into a structured review with one of three outcomes: <strong>approve</strong>, <strong>request changes</strong>, or <strong>comments</strong>. The skill does NOT fix code — it only reviews.</p>`,
    meta: { output: 'Review feedback', skill: 'technical-review', discovery: 'discovery-for-implementation-and-review.sh' }
  },
  'start-feature': {
    summary: 'Shortcut to specification — bypass research and discussion phases entirely.',
    body: `<p>For adding features to existing projects where you already know what you're building. No migration step, no discovery script. Gathers feature context inline (what, scope, constraints), suggests a topic name, checks for naming conflicts in <code>docs/workflow/specification/</code>, then invokes the <strong>technical-specification</strong> skill directly.</p>
<p>Output is a standard specification file that continues to <code>/start-planning</code> normally.</p>`,
    meta: { output: 'docs/workflow/specification/{topic}.md', skill: 'technical-specification', complexity: 'Shortcut' }
  },
  'link-deps': {
    summary: 'Wire up cross-topic dependencies across all plans with bidirectional linking.',
    body: `<p>Works across all plans simultaneously. Requires 2+ plans with the same output format. Three terminal gates: insufficient plans, inconsistent formats, and no unresolved dependencies.</p>
<p>Extracts external dependencies from all plans, matches unresolved deps to tasks in other plans, wires up bidirectional links (both the depending and depended-upon plans are updated), and commits the changes. Dependency states: <strong>unresolved</strong> → <strong>resolved</strong> (matched to task ID) or <strong>satisfied externally</strong> (manually marked).</p>`,
    meta: { complexity: 'Cross-plan utility' }
  },
  'skill-research': {
    summary: 'The research skill — an interactive exploration loop across technical, product, and market domains.',
    body: `<p>Acts as a research partner. Uses structured questioning from <code>references/interview.md</code> to guide exploration. The core loop: <strong>Ask → Discuss → Document → Commit → Repeat</strong>.</p>
<p>Output starts as a single <code>exploration.md</code> file and splits into separate files as distinct themes emerge. Research is open-ended — there is no formal "conclusion" status. When enough insight has accumulated, the user moves to discussion.</p>`,
    meta: { output: 'docs/workflow/research/', complexity: 'Looping skill' }
  },
  'skill-discussion': {
    summary: 'The discussion skill — captures decisions, debates, and edge cases through structured dialogue.',
    body: `<p>Engages as an expert architect and meeting assistant. The core loop: <strong>Engage → Capture decisions → Write to disk → Commit → Repeat</strong> until the discussion is concluded. Writes happen at natural pauses — partial and provisional documentation is expected and valuable.</p>
<p>Each question is structured as <strong>Options → Journey → Decision</strong>. The skill documents competing solutions and why choices were made, capturing the full reasoning trail. The file on disk is the defence against context compaction — what's not written is lost. Frontmatter status progresses from <code>in-progress</code> to <code>concluded</code>.</p>`,
    meta: { output: 'docs/workflow/discussion/{topic}.md', complexity: 'Looping skill' }
  },
  'skill-specification': {
    summary: 'The specification skill — collaborative refinement that filters hallucinations and enriches gaps.',
    body: `<p>Processes each topic through: <strong>Extract → Filter (validate against source) → Enrich (fill gaps) → Present → STOP &amp; WAIT for approval → Log</strong>. The skill is collaborative, not autonomous — it must wait for explicit user approval before writing anything.</p>
<p>Self-check before every write: "Was this presented? Was it approved?" Final review includes source traceability and supersede handling for replaced specifications.</p>`,
    meta: { output: 'docs/workflow/specification/{topic}.md', complexity: 'Collaborative skill' }
  },
  'skill-planning': {
    summary: 'The planning skill — three nested loops with agent-driven phase design, task design, and task authoring.',
    body: `<p>Setup: <strong>Resume detection</strong> (existing plan? continue/restart? spec-change detection) → <strong>Initialise</strong> (choose output format, create plan index) → <strong>Load principles</strong> → <strong>Verify source material</strong>.</p>
<p><strong>Plan construction</strong> is a three-level nested loop. Outer: invoke <strong>planning-phase-designer</strong> agent → user approval gate (revise backloop). Middle: for each phase, invoke <strong>planning-task-designer</strong> agent → approval gate. Inner: for each task, invoke <strong>planning-task-author</strong> agent → approval gate → log task + commit. Independent tasks may be authored in parallel. User can navigate to any position at any approval gate.</p>
<p>Post-construction: <strong>planning-dependency-grapher</strong> agent analyzes the full task graph (dependencies, priorities, cycle detection) → approval gate. <strong>External dependencies</strong> are matched to tasks in other plans or left unresolved for <code>/link-dependencies</code>.</p>
<p><strong>Plan review</strong> runs two sequential reviews. <strong>Traceability</strong>: spec→plan completeness + plan→spec fidelity (anti-hallucination gate). <strong>Integrity</strong>: standalone structural quality (templates, slicing, dependencies, self-containment, criteria quality). Both create tracking files and process findings one-at-a-time with per-finding approval gates (approve/skip/revise).</p>`,
    meta: { output: 'docs/workflow/planning/{topic}.md', complexity: 'Multi-loop skill', agents: 'phase-designer, task-designer, task-author, dependency-grapher' }
  },
  'skill-implementation': {
    summary: 'The implementation skill — agent-based TDD with per-task executor/reviewer, linting, and analysis cycle.',
    body: `<p>Orchestrator dispatches <strong>two agents per task</strong>: an <strong>executor</strong> (implements via strict TDD with RED→GREEN→REFACTOR→LINT cycle) and an independent <strong>reviewer</strong> (verifies correctness, opus model). Neither agent sees the other's context.</p>
<p><strong>Task loop</strong> (Step 6): Five stages per task — <strong>A.</strong> Retrieve next task → <strong>B.</strong> Invoke executor (blocked? → user decides: retry/skip/stop) → <strong>C.</strong> Invoke reviewer (needs changes? → <strong>fix_gate_mode</strong> controls: auto re-invokes executor, gated presents findings with fix analysis) → <strong>D.</strong> Task gate (<strong>task_gate_mode</strong>: gated waits for approval, auto announces only) → <strong>E.</strong> Update plan + commit. Loop until all tasks done.</p>
<p><strong>Analysis loop</strong> (Step 7): After task loop, dispatch <strong>3 analysis agents in parallel</strong> (duplication, standards, architecture) → <strong>synthesizer</strong> deduplicates and normalizes into tasks → user approves/skips each task individually → approved tasks are added to the plan as a new phase → <strong>re-enter task loop</strong>. Up to 3 cycles, user prompted to continue beyond that.</p>`,
    meta: { complexity: 'Agent-based TDD' }
  },
  'skill-review': {
    summary: 'The review skill — parallel fan-out verification of every task in the plan.',
    body: `<p>Reads the plan and specification, extracts ALL tasks, then spawns <strong>parallel review-task-verifier subagents</strong> (Haiku model, one per task). All verifiers run simultaneously for efficiency.</p>
<p>Each review-task-verifier checks: implementation correctness, acceptance criteria coverage, test adequacy, and code quality. Results are aggregated into a structured review and the skill produces a final assessment. It does not fix code — only identifies issues.</p>`,
    meta: { complexity: 'Parallel fan-out' }
  },
  'status': {
    summary: 'Quick workflow status overview — scan all directories and suggest next steps.',
    body: `<p>Runs <code>/migrate</code> first (pausing for review if files were updated), then scans all workflow directories: research, discussion, specification, and planning.</p>
<p>Presents a table organised by topic showing progress across all 6 phases, then recommends which workflow command to run next based on the current state. No discovery script — uses direct directory scans.</p>`,
    meta: { complexity: 'Utility' }
  },
  'view-plan': {
    summary: 'Format-aware plan viewer — reads any plan regardless of output format.',
    body: `<p>Checks for existing plans (stops if none found). If multiple plans exist, asks which to view. Reads the plan index and frontmatter to determine the output format, loads the corresponding format reference file, then follows that format's reading instructions.</p>
<p>Presents a summary with phases, tasks, progress status, and dependencies. Works with any output format because it dynamically loads the format adapter.</p>`,
    meta: { complexity: 'Utility' }
  },
  'migrate': {
    summary: 'Migration orchestrator — keeps workflow files in sync with the current system design.',
    body: `<p>Executes <code>skills/migrate/scripts/migrate.sh</code>, which runs all numbered scripts in <code>skills/migrate/scripts/migrations/</code> in order. Each migration is idempotent — safe to run multiple times. Progress is tracked in <code>docs/workflow/.cache/migrations.log</code>.</p>
<p>Runs automatically as <strong>Step 0 of every workflow command</strong>. If files were updated, shows changes and waits for user review via git diff. Delete the log file to force re-running all migrations.</p>`,
    meta: { complexity: 'System' }
  },
  'planning-phase-designer': {
    summary: 'Design implementation phases from a specification — goals, sequencing, and acceptance criteria.',
    body: `<p>Reads the specification via ingestion protocol, then loads phase and task design principles. Designs a phased implementation structure with clear goals and acceptance criteria for each phase.</p>
<p>Supports <strong>amendment rounds</strong> — if prior output and feedback are provided, the agent revises its design rather than starting fresh. Output is a human-readable phase summary.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-planning', complexity: 'Subagent' }
  },
  'planning-task-designer': {
    summary: 'Break a single phase into concrete tasks with edge cases and dependencies.',
    body: `<p>Reads the specification, approved phases, and task design principles. For the target phase, produces a detailed task list with edge cases identified per task.</p>
<p>Supports <strong>amendment rounds</strong> — revises task list based on feedback when prior output exists. Output is a task table with IDs, names, edge cases, and status.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-planning', complexity: 'Subagent' }
  },
  'planning-task-author': {
    summary: 'Author full task detail in the plan\'s output format — problem, solution, acceptance criteria, tests.',
    body: `<p>Reads specification, task template, phases, task list, and the <strong>output format adapter</strong> (authoring.md). Writes complete task detail in the exact format structure: problem, solution, outcome, do/don\'t, acceptance criteria, tests, and context.</p>
<p>Supports <strong>amendment rounds</strong>. Format-aware — adapts to whichever output format the plan uses.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-planning', complexity: 'Subagent' }
  },
  'planning-dependency-grapher': {
    summary: 'Analyze task dependencies, detect circular references, and assign priority classifications.',
    body: `<p>Reads format adapters (reading.md + graph.md), then the plan index and all authored task files. <strong>Clears existing graph data</strong> before re-analysis to ensure a clean state.</p>
<p>For each task, extracts what it produces and requires, then matches across all tasks to build a dependency graph. Classifies tasks as <strong>bottleneck</strong>, <strong>foundation</strong>, or <strong>leaf</strong>. If <strong>cycles are detected</strong>, reports the cycle chain and does NOT apply changes — a hard stop. Otherwise, writes dependency and priority data back to tasks.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-planning', complexity: 'Subagent' }
  },
  'implementation-task-executor': {
    summary: 'Implement a single task via strict TDD — RED/GREEN/REFACTOR/LINT cycle per acceptance criterion.',
    body: `<p>Reads TDD workflow, code quality standards, project skills, and specification. Explores the codebase first to understand existing patterns.</p>
<p>Executes a <strong>strict TDD loop</strong> per acceptance criterion: <strong>RED</strong> (write failing test) → <strong>GREEN</strong> (implement to pass) → <strong>REFACTOR</strong> (improve code, run tests) → <strong>LINT</strong> (run configured linters, fix issues, revert if tests break). Has hard stops for scope expansion, uncertainty, and untenable spec decisions — reports back rather than making autonomous choices.</p>
<p>Returns a structured <strong>STATUS report</strong> (complete/blocked/failed) with files changed, tests written, and results.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-implementation', complexity: 'Subagent' }
  },
  'implementation-task-reviewer': {
    summary: 'Independently review a task across 6 dimensions with fix recommendations — no access to executor context.',
    body: `<p>Reads the specification, project skills, and integration context file, then checks unstaged changes via git diff/status and reads all changed files. <strong>Independent from the executor</strong> — no shared context.</p>
<p>Evaluates across <strong>6 dimensions</strong>: spec conformance, acceptance criteria coverage, test adequacy, convention adherence, architectural quality, and <strong>codebase cohesion</strong> (DRY, naming consistency, helper reuse). Produces a structured verdict (<strong>approved</strong> or <strong>needs-changes</strong>) with file:line references.</p>
<p>When returning <strong>needs-changes</strong>, each issue includes <strong>FIX</strong> (recommended approach), optional <strong>ALTERNATIVE</strong> (when multiple valid approaches exist), and <strong>CONFIDENCE</strong> (high/medium/low) — giving visibility into the fix strategy before re-execution.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-implementation', complexity: 'Subagent' }
  },
  'review-task-verifier': {
    summary: 'Verify a single task\'s implementation, tests, and code quality against the plan and spec.',
    body: `<p>Spawned <strong>in parallel</strong> (one per task) by the technical-review skill. Reads the task details, then loads the broader specification context.</p>
<p>Three verification stages: <strong>implementation</strong> (exists, matches criteria, aligns with spec), <strong>tests</strong> (adequate coverage, edge cases, not over/under-tested), and <strong>code quality</strong> (conventions, SOLID, DRY, complexity, security, performance). Compiles a structured finding with blocking issues and non-blocking notes.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-review', complexity: 'Subagent' }
  },
  'implementation-analysis-duplication': {
    summary: 'Hunt for cross-file duplication, near-duplicate logic, and extraction candidates.',
    body: `<p>Analyses code that was independently written by separate task executors who couldn't see each other's work. Read-only — writes only a findings file.</p>
<p>Focus areas: <strong>cross-file repeated patterns</strong>, <strong>near-duplicate logic</strong> (slightly different implementations of the same concept), <strong>helper extraction candidates</strong> (inline code that should be shared), and <strong>copy-paste drift</strong> across task boundaries.</p>
<p>Proportional analysis — three similar lines is not worth flagging, but three similar 20-line blocks is. Plan scope only.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-implementation', tools: 'Read, Write, Glob, Grep, Bash', complexity: 'Analysis agent' }
  },
  'implementation-analysis-standards': {
    summary: 'The specification\'s advocate — find where implementation drifts from what was decided.',
    body: `<p>Analyses the implementation as the specification's advocate. Read-only — writes only a findings file.</p>
<p>Focus areas: <strong>spec conformance</strong> (does the code match what was specified?), <strong>project skill compliance</strong> (MUST DO/MUST NOT DO rules), <strong>spec-vs-convention conflicts</strong> (when spec conflicts with language idiom, which won?), and <strong>missing validations/constraints</strong> from spec.</p>
<p>Plan scope only — does not flag pre-existing drift in code that wasn't part of this implementation.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-implementation', tools: 'Read, Write, Glob, Grep, Bash', complexity: 'Analysis agent' }
  },
  'implementation-analysis-architecture': {
    summary: 'Review the completed implementation as an architect who didn\'t write it.',
    body: `<p>Reviews the implementation from an architectural perspective. Read-only — writes only a findings file.</p>
<p>Focus areas: <strong>API surface quality</strong>, <strong>package/module structure</strong>, <strong>integration test gaps</strong> for cross-task workflows, <strong>seam quality</strong> between task boundaries, and <strong>over/under-engineering</strong>.</p>
<p>Proportional and plan-scoped — focuses on high-impact issues, not cosmetic preferences.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-implementation', tools: 'Read, Write, Glob, Grep, Bash', complexity: 'Analysis agent' }
  },
  'implementation-analysis-synthesizer': {
    summary: 'Synthesize findings from 3 analysis agents into deduplicated, normalized tasks for user approval.',
    body: `<p>Locates findings files from the 3 analysis agents by convention (topic directory), reads them, then performs multi-step synthesis.</p>
<p><strong>Process</strong>: deduplicate (same issue from multiple agents → one finding) → group related findings into single tasks → filter by severity (never discard high) → normalize into canonical task template (Problem/Solution/Outcome/Do/AC/Tests).</p>
<p>Writes two outputs: an <strong>analysis report</strong> (summary + discarded findings) and a <strong>staging file</strong> (proposed tasks with <code>status: pending</code>) for the orchestrator to present to the user.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-implementation', tools: 'Read, Write, Glob, Grep', complexity: 'Synthesis agent' }
  },
  'implementation-analysis-task-writer': {
    summary: 'Create plan tasks from approved analysis findings using the format\'s authoring adapter.',
    body: `<p>Invoked after the user approves analysis tasks. Reads the staging file, extracts tasks with <code>status: approved</code>, determines the next phase number, and creates tasks in the plan.</p>
<p>Uses the plan format's <strong>authoring adapter</strong> to create tasks in the correct format (local-markdown file creation, Linear API calls, etc.). The topic name scopes tasks to the correct plan.</p>
<p>Hard rules: approved only, no content modifications, no git writes (orchestrator commits), authoring adapter is authoritative.</p>`,
    meta: { model: 'Opus', invokedBy: 'technical-implementation', tools: 'Read, Write, Edit, Glob, Grep, Bash', complexity: 'Task creation agent' }
  },
};

// ── Source File Mapping (flowchart key → repo-relative path) ──
const GITHUB_RAW_BASE = 'https://raw.githubusercontent.com/leeovery/claude-technical-workflows/main/';

const SOURCE_MAP = {
  'research':             'skills/start-research/SKILL.md',
  'discussion':           'skills/start-discussion/SKILL.md',
  'specification':        'skills/start-specification/SKILL.md',
  'planning':             'skills/start-planning/SKILL.md',
  'implementation':       'skills/start-implementation/SKILL.md',
  'review':               'skills/start-review/SKILL.md',
  'skill-research':       'skills/technical-research/SKILL.md',
  'skill-discussion':     'skills/technical-discussion/SKILL.md',
  'skill-specification':  'skills/technical-specification/SKILL.md',
  'skill-planning':       'skills/technical-planning/SKILL.md',
  'skill-implementation': 'skills/technical-implementation/SKILL.md',
  'skill-review':         'skills/technical-review/SKILL.md',
  'start-feature':        'skills/start-feature/SKILL.md',
  'link-deps':            'skills/link-dependencies/SKILL.md',
  'status':               'skills/status/SKILL.md',
  'view-plan':            'skills/view-plan/SKILL.md',
  'migrate':              'skills/migrate/SKILL.md',
  'planning-phase-designer':      'agents/planning-phase-designer.md',
  'planning-task-designer':       'agents/planning-task-designer.md',
  'planning-task-author':         'agents/planning-task-author.md',
  'planning-dependency-grapher':  'agents/planning-dependency-grapher.md',
  'implementation-task-executor': 'agents/implementation-task-executor.md',
  'implementation-task-reviewer': 'agents/implementation-task-reviewer.md',
  'implementation-analysis-duplication':  'agents/implementation-analysis-duplication.md',
  'implementation-analysis-standards':   'agents/implementation-analysis-standards.md',
  'implementation-analysis-architecture':'agents/implementation-analysis-architecture.md',
  'implementation-analysis-synthesizer': 'agents/implementation-analysis-synthesizer.md',
  'implementation-analysis-task-writer': 'agents/implementation-analysis-task-writer.md',
  'review-task-verifier':         'agents/review-task-verifier.md',
};

// ── Markdown Viewer ──
const _mdCache = {};
let _mdHistory = []; // [{path, scrollTop, anchor}]

function openMdViewer(key, scrollAnchor) {
  const path = SOURCE_MAP[key];
  if (!path) return;
  _mdHistory = [];
  loadMdFile(path, scrollAnchor, false);
  document.getElementById('md-viewer').classList.add('open');
  document.getElementById('md-viewer-backdrop').classList.add('visible');
}

function closeMdViewer() {
  document.getElementById('md-viewer').classList.remove('open');
  document.getElementById('md-viewer-backdrop').classList.remove('visible');
  _mdHistory = [];
}

function loadMdFile(path, anchor, isBack) {
  const body = document.getElementById('md-viewer-body');
  body.innerHTML = '<div class="md-viewer-loading">Loading...</div>';

  if (!isBack && _mdHistory.length > 0) {
    // Save scroll position of current page before navigating
    const last = _mdHistory[_mdHistory.length - 1];
    last.scrollTop = body.scrollTop;
  }

  if (!isBack) {
    _mdHistory.push({ path, scrollTop: 0, anchor });
  }

  updateMdBreadcrumb();
  updateMdBackButton();
  document.getElementById('md-viewer-github').href = 'https://github.com/leeovery/claude-technical-workflows/blob/main/' + path;

  const url = GITHUB_RAW_BASE + path;

  if (_mdCache[path]) {
    renderMdContent(_mdCache[path], anchor);
    return;
  }

  fetch(url)
    .then(r => {
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return r.text();
    })
    .then(text => {
      _mdCache[path] = text;
      // Only render if still on this path
      if (_mdHistory.length > 0 && _mdHistory[_mdHistory.length - 1].path === path) {
        renderMdContent(text, anchor);
      }
    })
    .catch(err => {
      body.innerHTML = `<div class="md-viewer-error">Failed to load: ${path}<br><small>${err.message}</small></div>`;
    });
}

function renderMdContent(raw, anchor) {
  const body = document.getElementById('md-viewer-body');
  // Strip YAML frontmatter
  let content = raw;
  if (content.startsWith('---')) {
    const end = content.indexOf('---', 3);
    if (end !== -1) content = content.slice(end + 3).trim();
  }
  body.innerHTML = marked.parse(content);
  interceptMdLinks(body, _mdHistory[_mdHistory.length - 1].path);
  if (anchor) {
    setTimeout(() => scrollToMdAnchor(anchor), 50);
  } else {
    body.scrollTop = 0;
  }
}

function interceptMdLinks(container, currentPath) {
  const links = container.querySelectorAll('a');
  const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
  links.forEach(a => {
    const href = a.getAttribute('href');
    if (!href) return;
    // External or absolute links open in new tab
    if (href.startsWith('http://') || href.startsWith('https://') || href.startsWith('//')) {
      a.target = '_blank';
      a.rel = 'noopener';
      return;
    }
    // Relative .md links navigate within viewer
    if (href.endsWith('.md') || href.includes('.md#')) {
      a.addEventListener('click', (e) => {
        e.preventDefault();
        let [filePart, anchorPart] = href.split('#');
        // Resolve relative path
        let resolved = currentDir + filePart;
        // Normalize ../
        const parts = resolved.split('/');
        const normalized = [];
        for (const p of parts) {
          if (p === '..') normalized.pop();
          else if (p !== '.') normalized.push(p);
        }
        loadMdFile(normalized.join('/'), anchorPart || null, false);
      });
      a.style.cursor = 'pointer';
    }
  });
}

function updateMdBreadcrumb() {
  const bc = document.getElementById('md-viewer-breadcrumb');
  bc.innerHTML = _mdHistory.map((entry, i) => {
    const filename = entry.path.split('/').pop();
    if (i === _mdHistory.length - 1) {
      return `<span class="current">${filename}</span>`;
    }
    return `<span onclick="mdViewerNavigateTo(${i})">${filename}</span>`;
  }).join(' &rsaquo; ');
}

function updateMdBackButton() {
  document.getElementById('md-viewer-back').disabled = _mdHistory.length <= 1;
}

function mdViewerBack() {
  if (_mdHistory.length <= 1) return;
  _mdHistory.pop();
  const prev = _mdHistory[_mdHistory.length - 1];
  // Re-render from cache (already visited)
  const body = document.getElementById('md-viewer-body');
  if (_mdCache[prev.path]) {
    renderMdContent(_mdCache[prev.path], null);
    setTimeout(() => { body.scrollTop = prev.scrollTop || 0; }, 50);
  } else {
    _mdHistory.pop(); // Remove so loadMdFile re-adds it
    loadMdFile(prev.path, prev.anchor, false);
  }
  updateMdBreadcrumb();
  updateMdBackButton();
}

function mdViewerNavigateTo(index) {
  if (index < 0 || index >= _mdHistory.length - 1) return;
  // Save current scroll before navigating
  const body = document.getElementById('md-viewer-body');
  const cur = _mdHistory[_mdHistory.length - 1];
  cur.scrollTop = body.scrollTop;

  // Trim history to target
  _mdHistory = _mdHistory.slice(0, index + 1);
  const target = _mdHistory[_mdHistory.length - 1];
  if (_mdCache[target.path]) {
    renderMdContent(_mdCache[target.path], null);
    setTimeout(() => { body.scrollTop = target.scrollTop || 0; }, 50);
  } else {
    _mdHistory.pop();
    loadMdFile(target.path, target.anchor, false);
  }
  updateMdBreadcrumb();
  updateMdBackButton();
}

function scrollToMdAnchor(anchor) {
  const body = document.getElementById('md-viewer-body');
  // Try heading ID match first (marked.js generates slug IDs)
  const slug = anchor.toLowerCase().replace(/[^\w]+/g, '-').replace(/^-|-$/g, '');
  let el = body.querySelector('#' + CSS.escape(slug));
  if (!el) el = body.querySelector('[id="' + slug + '"]');
  // Fallback: search heading text
  if (!el) {
    const headings = body.querySelectorAll('h1, h2, h3, h4, h5, h6');
    for (const h of headings) {
      if (h.textContent.toLowerCase().includes(anchor.toLowerCase())) {
        el = h; break;
      }
    }
  }
  // Fallback: search any text
  if (!el) {
    const all = body.querySelectorAll('p, li, td');
    for (const p of all) {
      if (p.textContent.toLowerCase().includes(anchor.toLowerCase())) {
        el = p; break;
      }
    }
  }
  if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function openMdViewerFromTooltip() {
  const tooltip = document.getElementById('fc-tooltip');
  const key = state.selectedFlowchart;
  if (!key || !SOURCE_MAP[key]) return;
  const nodeId = tooltip.dataset.nodeId;
  const nodes = getNodes();
  const node = nodes.find(n => n.id === nodeId);
  let anchor = null;
  if (node && node.desc) {
    // Extract step number: "Step 5:" → "Step 5"
    const stepMatch = node.desc.match(/Step\s+(\d+)/i);
    if (stepMatch) {
      anchor = 'step ' + stepMatch[1];
    } else {
      anchor = node.label;
    }
  }
  hideFcTooltip();
  openMdViewer(key, anchor);
}

// ── Rendering ──
const svg = document.getElementById('svg-canvas');
const canvasArea = document.getElementById('canvas-area');

function getNodes() {
  if (state.view === 'flowchart') {
    if (!state.selectedFlowchart || !FLOWCHARTS[state.selectedFlowchart]) return [];
    return computeFlowchartLayout(state.selectedFlowchart).nodes;
  }
  return OVERVIEW_NODES;
}
function getConnections() {
  if (state.view === 'flowchart') return state.selectedFlowchart && FLOWCHARTS[state.selectedFlowchart] ? FLOWCHARTS[state.selectedFlowchart].connections : [];
  return OVERVIEW_CONNECTIONS;
}

function getNodeById(id) {
  return getNodes().find(n => n.id === id);
}

// Diamond boundary clipping helper
function clipToDiamond(cx, cy, hw, hh, px, py) {
  const dx = px - cx, dy = py - cy;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  const sum = adx / hw + ady / hh;
  if (sum <= 1) return { x: px, y: py };
  return { x: cx + dx / sum, y: cy + dy / sum };
}

// Simple direction-based snap for incoming edges to diamonds.
// Uses dominant axis: vertical → top/bottom vertex, horizontal → left/right vertex.
function snapToDiamondPort(cx, cy, hw, hh, pt) {
  const dx = pt.x - cx, dy = pt.y - cy;
  if (Math.abs(dx) >= Math.abs(dy)) {
    return dx >= 0 ? { x: cx + hw, y: cy } : { x: cx - hw, y: cy };
  } else {
    return dy >= 0 ? { x: cx, y: cy + hh } : { x: cx, y: cy - hh };
  }
}

// Context-aware outgoing port assignment for diamond nodes.
// Distributes outgoing edges across diamond ports based on count:
//   1 down → bottom vertex
//   2 down → lower-left midpoint + lower-right midpoint
//   3 down → lower-left midpoint + bottom vertex + lower-right midpoint
//   4 down → left vertex + lower-left + lower-right + right vertex
//   5 down → left + lower-left + bottom + lower-right + right
// Side edges (same rank, far horizontal) → left/right vertex.
// Upward edges (backloop) → top vertex.
function computeDiamondPorts(nodes, connections) {
  const ports = {};
  // Group outgoing edges by source diamond
  const diamondOut = {};
  connections.forEach(c => {
    const from = nodes.find(n => n.id === c.from);
    if (!from || from.shape !== 'diamond') return;
    if (!diamondOut[c.from]) diamondOut[c.from] = [];
    diamondOut[c.from].push(c);
  });

  for (const [nodeId, edges] of Object.entries(diamondOut)) {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) continue;
    const cx = node.x + node.w / 2, cy = node.y + node.h / 2;
    const hw = node.w / 2, hh = node.h / 2;

    // Classify by target position relative to diamond
    // Edges can specify explicit port hints: 'left', 'right', 'top', 'bottom',
    // 'lower-left', 'lower-right', 'upper-left', 'upper-right'
    const portMap = {
      'left': { x: cx - hw, y: cy }, 'right': { x: cx + hw, y: cy },
      'top': { x: cx, y: cy - hh }, 'bottom': { x: cx, y: cy + hh },
      'lower-left': { x: cx - hw / 2, y: cy + hh / 2 },
      'lower-right': { x: cx + hw / 2, y: cy + hh / 2 },
      'upper-left': { x: cx - hw / 2, y: cy - hh / 2 },
      'upper-right': { x: cx + hw / 2, y: cy - hh / 2 },
    };
    const downEdges = [], upEdges = [];
    edges.forEach(e => {
      // Honor explicit port hint
      if (e.port && portMap[e.port]) {
        ports[e.from + '->' + e.to] = portMap[e.port];
        return;
      }
      const to = nodes.find(n => n.id === e.to);
      if (!to) return;
      const toCx = to.x + to.w / 2, toCy = to.y + to.h / 2;
      const dx = toCx - cx, dy = toCy - cy;
      if (dy < -10) {
        upEdges.push({ edge: e, dx, dy });
      } else {
        // Everything at same level or below → treat as downward.
        // Sorting by dx distributes them across lower ports (left-to-right).
        downEdges.push({ edge: e, dx, dy });
      }
    });

    // Up edges → top vertex
    upEdges.forEach(({ edge }) => {
      ports[edge.from + '->' + edge.to] = { x: cx, y: cy - hh };
    });

    // Down edges → distribute across lower ports based on count
    downEdges.sort((a, b) => a.dx - b.dx); // sort left-to-right
    const ll = { x: cx - hw / 2, y: cy + hh / 2 }; // lower-left midpoint
    const bb = { x: cx, y: cy + hh };                // bottom vertex
    const lr = { x: cx + hw / 2, y: cy + hh / 2 };  // lower-right midpoint
    const lv = { x: cx - hw, y: cy };                // left vertex
    const rv = { x: cx + hw, y: cy };                // right vertex
    let downPorts;
    switch (downEdges.length) {
      case 0: downPorts = []; break;
      case 1: downPorts = [bb]; break;
      case 2: downPorts = [ll, lr]; break;
      case 3: downPorts = [ll, bb, lr]; break;
      case 4: downPorts = [lv, ll, lr, rv]; break;
      case 5: downPorts = [lv, ll, bb, lr, rv]; break;
      default: downPorts = [lv, ll, bb, lr, rv]; break;
    }
    downEdges.forEach(({ edge }, i) => {
      ports[edge.from + '->' + edge.to] = downPorts[Math.min(i, downPorts.length - 1)];
    });
  }
  return ports;
}

function renderSVG() {
  const nodes = getNodes();
  const conns = getConnections();
  const isFlowchart = state.view === 'flowchart';

  // Get dagre edge points for flowchart view
  let fcEdgePoints = null;
  let diamondPorts = null;
  if (isFlowchart && state.selectedFlowchart) {
    fcEdgePoints = computeFlowchartLayout(state.selectedFlowchart).edgePoints;
    diamondPorts = computeDiamondPorts(nodes, conns);
  }

  // Calculate bounds — symmetric padding using actual min/max of all nodes
  if (nodes.length === 0) {
    svg.setAttribute('viewBox', '0 0 100 100');
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.innerHTML = '';
    return;
  }
  let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
  nodes.forEach(n => {
    minX = Math.min(minX, n.x);
    minY = Math.min(minY, n.y);
    maxX = Math.max(maxX, n.x + n.w);
    maxY = Math.max(maxY, n.y + n.h);
  });
  const pad = 40; // base padding in SVG units (all sides)
  // Scale-aware top/bottom clearance for UI overlays (burger menu, zoom controls).
  // When height constrains the fit, we solve for the viewBox height that guarantees
  // the desired screen-pixel clearance at the FINAL scale, not the pre-padding scale.
  const rawW = maxX - minX + pad * 2;
  const rawH = maxY - minY + pad * 2;
  const canvasW = svg.clientWidth || 800;
  const canvasH = svg.clientHeight || 600;
  let extraTop = 0, extraBottom = 0;
  if (rawH / canvasH > rawW / canvasW) {
    // Height-constrained: viewBox height maps exactly to canvas height
    const topClearPx = 48;
    const bottomClearPx = 52;
    const usableFrac = 1 - (topClearPx + bottomClearPx) / canvasH;
    const finalH = rawH / usableFrac;
    extraTop = Math.max(0, finalH * (topClearPx / canvasH) - pad);
    extraBottom = Math.max(0, finalH * (bottomClearPx / canvasH) - pad);
  }
  const contentW = rawW;
  const contentH = rawH + extraTop + extraBottom;
  svg.setAttribute('viewBox', `${minX - pad} ${minY - pad - extraTop} ${contentW} ${contentH}`);
  svg.style.width = '100%';
  svg.style.height = '100%';

  let html = `
    <defs>
      <marker id="arrow-flow" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#6c8aff"/>
      </marker>
      <marker id="arrow-output" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#34d399"/>
      </marker>
      <marker id="arrow-feed" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#60a5fa"/>
      </marker>
      <marker id="arrow-skill" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#f97316"/>
      </marker>
      <marker id="arrow-system" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#6c8aff"/>
      </marker>
      <marker id="arrow-shortcut" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#818cf8"/>
      </marker>
      <marker id="arrow-cache" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#fbbf24"/>
      </marker>
      <marker id="arrow-yes" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#34d399"/>
      </marker>
      <marker id="arrow-no" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#f43f5e"/>
      </marker>
      <marker id="arrow-transition" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#f97316"/>
      </marker>
      <marker id="arrow-backloop" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#6b7280"/>
      </marker>
      <marker id="arrow-default" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="#8b90a0"/>
      </marker>
    </defs>
  `;

  // Draw connections
  conns.forEach(c => {
    const from = getNodeById(c.from);
    const to = getNodeById(c.to);
    if (!from || !to) return;

    const fx = from.x + from.w;
    const fy = from.y + from.h / 2;
    const tx = to.x;
    const ty = to.y + to.h / 2;

    // Determine path style
    let strokeColor, dashArray, marker;
    switch (c.type) {
      case 'flow':
        strokeColor = '#6c8aff'; dashArray = ''; marker = 'url(#arrow-flow)'; break;
      case 'output':
        strokeColor = '#34d399'; dashArray = ''; marker = 'url(#arrow-output)'; break;
      case 'feed':
        strokeColor = '#60a5fa'; dashArray = '6,3'; marker = 'url(#arrow-feed)'; break;
      case 'skill':
        strokeColor = '#f97316'; dashArray = '4,4'; marker = 'url(#arrow-skill)'; break;
      case 'system':
        strokeColor = '#6c8aff'; dashArray = '8,4'; marker = 'url(#arrow-system)'; break;
      case 'shortcut':
        strokeColor = '#818cf8'; dashArray = '6,3'; marker = 'url(#arrow-shortcut)'; break;
      case 'cache':
        strokeColor = '#fbbf24'; dashArray = '4,2'; marker = 'url(#arrow-cache)'; break;
      case 'yes':
        strokeColor = '#34d399'; dashArray = ''; marker = 'url(#arrow-yes)'; break;
      case 'no':
        strokeColor = '#f43f5e'; dashArray = ''; marker = 'url(#arrow-no)'; break;
      case 'transition':
        strokeColor = '#f97316'; dashArray = '6,4'; marker = 'url(#arrow-transition)'; break;
      case 'backloop':
        strokeColor = '#6b7280'; dashArray = '5,3'; marker = 'url(#arrow-backloop)'; break;
      default:
        strokeColor = '#8b90a0'; dashArray = ''; marker = 'url(#arrow-default)';
    }

    let sx, sy, ex, ey;
    const fromIsDiamond = from.shape === 'diamond';
    const toIsDiamond = to.shape === 'diamond';

    // Flowchart view: use dagre edge points
    if (isFlowchart && fcEdgePoints) {
      const edgeKey = c.from + '->' + c.to;
      const pts = fcEdgePoints[edgeKey];

      if (pts && pts.length >= 2) {
        // Clip endpoints to diamond boundaries if needed
        const fromCx = from.x + from.w / 2, fromCy = from.y + from.h / 2;
        const toCx = to.x + to.w / 2, toCy = to.y + to.h / 2;

        let startPt = pts[0];
        let endPt = pts[pts.length - 1];

        if (fromIsDiamond) {
          // Use pre-computed context-aware port for outgoing edges
          const portKey = c.from + '->' + c.to;
          if (diamondPorts && diamondPorts[portKey]) {
            startPt = diamondPorts[portKey];
          } else {
            startPt = clipToDiamond(fromCx, fromCy, from.w / 2, from.h / 2, pts[1] ? pts[1].x : endPt.x, pts[1] ? pts[1].y : endPt.y);
          }
        }
        if (toIsDiamond) {
          if (c.toPort) {
            // Explicit incoming port hint — use named position on target diamond
            const thw = to.w / 2, thh = to.h / 2;
            const toPortMap = {
              'left': { x: toCx - thw, y: toCy }, 'right': { x: toCx + thw, y: toCy },
              'top': { x: toCx, y: toCy - thh }, 'bottom': { x: toCx, y: toCy + thh },
              'lower-left': { x: toCx - thw / 2, y: toCy + thh / 2 },
              'lower-right': { x: toCx + thw / 2, y: toCy + thh / 2 },
              'upper-left': { x: toCx - thw / 2, y: toCy - thh / 2 },
              'upper-right': { x: toCx + thw / 2, y: toCy - thh / 2 },
            };
            endPt = toPortMap[c.toPort] || endPt;
          } else {
            // Use simple direction-based snap for incoming edges
            const prevPt = pts.length > 2 ? pts[pts.length - 2] : startPt;
            endPt = clipToDiamond(toCx, toCy, to.w / 2, to.h / 2, prevPt.x, prevPt.y);
            endPt = snapToDiamondPort(toCx, toCy, to.w / 2, to.h / 2, endPt);
          }
        }

        // When an explicit port hint overrides dagre's exit point, discard
        // dagre's intermediate waypoints — they were computed for a different
        // exit direction and create kinks.  Draw a direct line instead.
        // Skip dagre waypoints for port-hinted edges (they create kinks),
        // but keep them for backloops which need waypoints to route around nodes.
        const hasPortHint = c.port && c.type !== 'backloop' && diamondPorts && diamondPorts[c.from + '->' + c.to];
        const midPts = hasPortHint ? [] : pts.slice(1, -1);
        const allPts = [startPt, ...midPts, endPt];
        if (allPts.length === 2) {
          html += `<path d="M${allPts[0].x},${allPts[0].y} L${allPts[1].x},${allPts[1].y}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.6"/>`;
        } else {
          const cornerR = 8;
          let d = `M${allPts[0].x},${allPts[0].y}`;
          for (let i = 1; i < allPts.length - 1; i++) {
            const prev = allPts[i-1], curr = allPts[i], next = allPts[i+1];
            const dx1 = curr.x - prev.x, dy1 = curr.y - prev.y;
            const dx2 = next.x - curr.x, dy2 = next.y - curr.y;
            const l1 = Math.sqrt(dx1*dx1 + dy1*dy1);
            const l2 = Math.sqrt(dx2*dx2 + dy2*dy2);
            if (l1 < 1 || l2 < 1) { d += ` L${curr.x},${curr.y}`; continue; }
            const cr = Math.min(cornerR, l1 / 2, l2 / 2);
            d += ` L${curr.x - dx1/l1*cr},${curr.y - dy1/l1*cr}`;
            d += ` Q${curr.x},${curr.y} ${curr.x + dx2/l2*cr},${curr.y + dy2/l2*cr}`;
          }
          d += ` L${allPts[allPts.length-1].x},${allPts[allPts.length-1].y}`;
          html += `<path d="${d}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.6"/>`;
        }

        // Label position along dagre path
        if (c.label && from.shape === 'diamond') {
          // Position label near source diamond — dynamic distance based on
          // edge direction and label width to prevent overlap
          const segDx = allPts[1].x - allPts[0].x;
          const segDy = allPts[1].y - allPts[0].y;
          const segLen = Math.sqrt(segDx * segDx + segDy * segDy);
          if (segLen > 1) {
            const tw = c.label.length * 5.5 + 10; // label pill width
            const horizBias = Math.abs(segDx) / segLen; // 0=vertical, 1=horizontal
            const vertBias = Math.abs(segDy) / segLen;
            // Horizontal edges need more distance for wide labels (tw/2 + gap)
            // Vertical edges need less (just pill half-height + gap)
            const minDist = horizBias * (tw / 2 + 8) + vertBias * 22;
            const dist = Math.max(minDist, segLen * 0.3);
            sx = allPts[0].x + (segDx / segLen) * dist;
            sy = allPts[0].y + (segDy / segLen) * dist;
          } else {
            sx = allPts[0].x;
            sy = allPts[0].y;
          }
        } else if (allPts.length % 2 === 1) {
          const mi = Math.floor(allPts.length / 2);
          sx = allPts[mi].x; sy = allPts[mi].y;
        } else {
          const a = allPts[allPts.length/2 - 1], b = allPts[allPts.length/2];
          sx = (a.x + b.x) / 2; sy = (a.y + b.y) / 2;
        }
        ex = sx; ey = sy;
      } else {
        // Fallback: simple bezier
        const fromCx = from.x + from.w / 2, fromCy = from.y + from.h / 2;
        const toCx = to.x + to.w / 2, toCy = to.y + to.h / 2;
        sx = fromCx; sy = from.y + from.h;
        ex = toCx; ey = to.y;
        const midY = (sy + ey) / 2;
        html += `<path d="M${sx},${sy} C${sx},${midY} ${ex},${midY} ${ex},${ey}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.6"/>`;
      }
    }
    // Overview: bezier routing
    else if (Math.abs(from.x - to.x) < 20 && from.y !== to.y) {
      sx = from.x + from.w / 2;
      sy = from.y + from.h;
      ex = to.x + to.w / 2;
      ey = to.y;
      const midY = (sy + ey) / 2;
      html += `<path d="M${sx},${sy} C${sx},${midY} ${ex},${midY} ${ex},${ey}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.5"/>`;
    }
    else if (c.type === 'feed' && from.x > to.x) {
      sx = from.x;
      sy = from.y + from.h / 2;
      ex = to.x + to.w;
      ey = to.y + to.h / 2;
      const midX = (sx + ex) / 2;
      html += `<path d="M${sx},${sy} C${midX},${sy} ${midX},${ey} ${ex},${ey}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.4"/>`;
    }
    else if (c.type === 'shortcut') {
      // Detect horizontal vs vertical shortcut
      const fcy = from.y + from.h / 2, tcy = to.y + to.h / 2;
      if (Math.abs(fcy - tcy) < 40) {
        // Horizontal: right edge → left edge
        sx = from.x + from.w;
        sy = fcy;
        ex = to.x;
        ey = tcy;
        const midX = (sx + ex) / 2;
        html += `<path d="M${sx},${sy} C${midX},${sy} ${midX},${ey} ${ex},${ey}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.5"/>`;
      } else {
        sx = from.x + from.w / 2;
        sy = from.y + from.h;
        ex = to.x + to.w / 2;
        ey = to.y;
        html += `<path d="M${sx},${sy} C${sx},${sy+40} ${ex},${ey-40} ${ex},${ey}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.5"/>`;
      }
    }
    else {
      sx = fx; sy = fy;
      ex = tx; ey = ty;
      const midX = (sx + ex) / 2;
      html += `<path d="M${sx},${sy} C${midX},${sy} ${midX},${ey} ${ex},${ey}" stroke="${strokeColor}" stroke-width="1.5" fill="none" stroke-dasharray="${dashArray}" marker-end="${marker}" opacity="0.5"/>`;
    }

    // Label
    if (c.label) {
      const lx = (sx + ex) / 2;
      const ly = (sy + ey) / 2 - 6;
      const tw = c.label.length * 5.5 + 10;
      if (isFlowchart) {
        // Colored pill: solid dark base + color tint overlay (blocks arrows)
        const pillH = 16;
        html += `<rect x="${lx - tw/2}" y="${ly - 11}" width="${tw}" height="${pillH}" rx="4" fill="var(--bg)"/>`;
        html += `<rect x="${lx - tw/2}" y="${ly - 11}" width="${tw}" height="${pillH}" rx="4" fill="${strokeColor}" opacity="0.13"/>`;
        html += `<text x="${lx}" y="${ly}" fill="${strokeColor}" font-size="9" font-weight="600" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${c.label}</text>`;
      } else {
        html += `<rect x="${lx - tw/2}" y="${ly - 10}" width="${tw}" height="15" rx="7" fill="var(--surface)" opacity="0.9"/>`;
        html += `<text x="${lx}" y="${ly}" fill="${strokeColor}" font-size="9" text-anchor="middle" opacity="0.7" font-family="-apple-system,system-ui,sans-serif">${c.label}</text>`;
      }
    }
  });

  // Draw nodes
  nodes.forEach(n => {
    const selected = state.selectedPhase && n.phase === state.selectedPhase;
    const strokeW = selected ? 2 : 1;
    const strokeOpacity = selected ? 1 : (isFlowchart ? 0.7 : 0.5);
    const radius = n.type === 'gate' ? 4 : 8;
    const cx = n.x + n.w / 2;
    const cy = n.y + n.h / 2;
    const hasDesc = isFlowchart && n.desc;

    html += `<g class="svg-node" data-id="${n.id}" data-phase="${n.phase || ''}" style="cursor:${(n.phase || hasDesc || n.skillLink) ? 'pointer' : 'default'}">`;

    if (n.shape === 'diamond') {
      const hw = n.w / 2, hh = n.h / 2;
      html += `<polygon points="${cx},${cy - hh} ${cx + hw},${cy} ${cx},${cy + hh} ${cx - hw},${cy}" fill="${n.bg}" stroke="${n.color}" stroke-width="${strokeW}" stroke-opacity="${strokeOpacity}"/>`;
      // Text wrapping for diamonds: split long labels at nearest space to midpoint
      const label = n.label;
      if (label.length > 12) {
        const mid = Math.ceil(label.length / 2);
        const spaceBefore = label.lastIndexOf(' ', mid);
        const spaceAfter = label.indexOf(' ', mid);
        let breakAt;
        if (spaceBefore <= 0 && (spaceAfter < 0 || spaceAfter >= label.length - 1)) {
          breakAt = mid;
        } else if (spaceBefore <= 0) {
          breakAt = spaceAfter;
        } else if (spaceAfter < 0 || spaceAfter >= label.length - 1) {
          breakAt = spaceBefore;
        } else {
          breakAt = (mid - spaceBefore <= spaceAfter - mid) ? spaceBefore : spaceAfter;
        }
        const line1 = label.substring(0, breakAt);
        const line2 = label.substring(breakAt).trim();
        html += `<text x="${cx}" y="${cy - 4}" fill="${n.color}" font-size="11" font-weight="600" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${line1}</text>`;
        html += `<text x="${cx}" y="${cy + 10}" fill="${n.color}" font-size="11" font-weight="600" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${line2}</text>`;
      } else {
        html += `<text x="${cx}" y="${cy + 4}" fill="${n.color}" font-size="11" font-weight="600" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${label}</text>`;
      }
    } else if (n.shape === 'pill') {
      const pillR = n.h / 2;
      html += `<rect x="${n.x}" y="${n.y}" width="${n.w}" height="${n.h}" rx="${pillR}" fill="${n.bg}" stroke="${n.color}" stroke-width="${strokeW}" stroke-opacity="${strokeOpacity}"/>`;
      html += `<text x="${cx}" y="${cy + 4}" fill="${n.color}" font-size="11" font-weight="600" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${n.label}</text>`;
    } else if (n.shape === 'stop') {
      html += `<rect x="${n.x}" y="${n.y}" width="${n.w}" height="${n.h}" rx="3" fill="${n.bg}" stroke="${n.color}" stroke-width="${strokeW}" stroke-opacity="${strokeOpacity}"/>`;
      html += `<text x="${cx}" y="${cy + 4}" fill="${n.color}" font-size="11" font-weight="600" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${n.label}</text>`;
    } else {
      html += `<rect x="${n.x}" y="${n.y}" width="${n.w}" height="${n.h}" rx="${radius}" fill="${n.bg}" stroke="${n.color}" stroke-width="${strokeW}" stroke-opacity="${strokeOpacity}"/>`;
      html += `<text x="${cx}" y="${n.y + (n.h > 40 ? 20 : 15)}" fill="${n.color}" font-size="${n.type === 'phase' || n.type === 'standalone' ? 13 : 12}" font-weight="600" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${n.label}</text>`;
      if (n.subtitle) {
        html += `<text x="${cx}" y="${n.y + (n.h > 40 ? 35 : 27)}" fill="${n.color}" font-size="9" text-anchor="middle" opacity="0.6" font-family="SF Mono,monospace">${n.subtitle}</text>`;
      }
    }
    // Badge for nodes with skillLink (AGT/SKL/CMD) — matches sidebar badge style
    if (isFlowchart && n.skillLink && FLOWCHARTS[n.skillLink]) {
      const lt = getLinkType(n.skillLink);
      const badgeColors = {
        agt: { bg: 'rgba(34,211,238,0.15)', fg: '#22d3ee', border: 'rgba(34,211,238,0.35)' },
        skl: { bg: 'rgba(249,115,22,0.15)', fg: '#f97316', border: 'rgba(249,115,22,0.35)' },
        cmd: { bg: 'rgba(108,138,255,0.15)', fg: '#6c8aff', border: 'rgba(108,138,255,0.35)' },
      };
      const bc = badgeColors[lt.badge] || badgeColors.cmd;
      const bw = 26, bh = 14;
      const bx = n.x + n.w - bw - 4;
      const by = n.y + 4;
      html += `<rect x="${bx}" y="${by}" width="${bw}" height="${bh}" rx="3" fill="${bc.bg}" stroke="${bc.border}" stroke-width="0.75"/>`;
      html += `<text x="${bx + bw/2}" y="${by + 10}" fill="${bc.fg}" font-size="7.5" font-weight="700" letter-spacing="0.5" text-anchor="middle" font-family="-apple-system,system-ui,sans-serif">${lt.badge.toUpperCase()}</text>`;
    }
    html += `</g>`;
  });

  svg.innerHTML = html;

  // Attach click handlers
  svg.querySelectorAll('.svg-node').forEach(g => {
    const phase = g.dataset.phase;
    const nodeId = g.dataset.id;
    if (isFlowchart && nodeId) {
      g.addEventListener('click', (e) => {
        e.stopPropagation();
        showFcTooltip(nodeId, g);
      });
    } else if (phase) {
      g.addEventListener('click', () => selectPhase(phase));
    }
  });
}

// ── Flowchart Tooltip ──
function getLinkType(key) {
  if (key.startsWith('skill-')) return { type: 'skl', label: 'Go to skill \u2192', badge: 'skl' };
  const p = phases[key];
  if (p && p.cmd && p.cmd.startsWith('/')) return { type: 'cmd', label: 'Go to command \u2192', badge: 'cmd' };
  return { type: 'agt', label: 'Go to agent \u2192', badge: 'agt' };
}

function navigateFromTooltip() {
  const tooltip = document.getElementById('fc-tooltip');
  const target = tooltip.dataset.skillLink;
  if (target && FLOWCHARTS[target]) {
    hideFcTooltip();
    selectPhase(target);
  }
}

function showFcTooltip(nodeId, gEl) {
  const tooltip = document.getElementById('fc-tooltip');
  const nodes = getNodes();
  const node = nodes.find(n => n.id === nodeId);
  if (!node || (!node.desc && !node.skillLink)) {
    hideFcTooltip();
    return;
  }

  // Toggle: clicking same node hides
  if (tooltip.style.display === 'block' && tooltip.dataset.nodeId === nodeId) {
    hideFcTooltip();
    return;
  }

  document.getElementById('fc-tooltip-title').textContent = node.label;
  document.getElementById('fc-tooltip-desc').textContent = node.desc || '';
  tooltip.style.borderColor = node.color;
  tooltip.dataset.nodeId = nodeId;

  // Show/hide source button based on whether flowchart has a source file
  const sourceBtn = document.getElementById('fc-tooltip-source');
  sourceBtn.style.display = (state.selectedFlowchart && SOURCE_MAP[state.selectedFlowchart]) ? 'inline-block' : 'none';

  // Show/hide navigation link for skillLink nodes
  const linkEl = document.getElementById('fc-tooltip-link');
  if (node.skillLink && FLOWCHARTS[node.skillLink]) {
    const lt = getLinkType(node.skillLink);
    linkEl.textContent = lt.label;
    linkEl.style.display = 'block';
    tooltip.dataset.skillLink = node.skillLink;
  } else {
    linkEl.style.display = 'none';
    tooltip.dataset.skillLink = '';
  }

  // Position tooltip close to the clicked node (prefer above, fallback below/side)
  const svgRect = svg.getBoundingClientRect();
  const vb = svg.getAttribute('viewBox').split(' ').map(Number);
  const scaleX = svgRect.width / vb[2];
  const scaleY = svgRect.height / vb[3];

  const nodeCenterScreenX = svgRect.left + (node.x + node.w / 2 - vb[0]) * scaleX;
  const nodeTopScreenY = svgRect.top + (node.y - vb[1]) * scaleY;
  const nodeBottomScreenY = svgRect.top + (node.y + node.h - vb[1]) * scaleY;

  const canvasRect = canvasArea.getBoundingClientRect();
  const tooltipW = 300;
  const hasLink = node.skillLink && FLOWCHARTS[node.skillLink];
  const tooltipH = hasLink ? 100 : 80; // estimated — taller when nav link is shown

  // Center horizontally on the node
  let left = nodeCenterScreenX - canvasRect.left - tooltipW / 2;
  // Place above the node with a small gap
  let top = nodeTopScreenY - canvasRect.top - tooltipH - 8;

  // If not enough room above, place below the node
  if (top < 8) {
    top = nodeBottomScreenY - canvasRect.top + 8;
  }
  // Keep horizontal within canvas bounds
  if (left + tooltipW > canvasRect.width - 8) left = canvasRect.width - tooltipW - 8;
  if (left < 8) left = 8;
  // Keep vertical within canvas bounds
  if (top + tooltipH > canvasRect.height - 8) top = canvasRect.height - tooltipH - 8;
  if (top < 8) top = 8;

  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
  tooltip.style.display = 'block';
}

function hideFcTooltip() {
  const tooltip = document.getElementById('fc-tooltip');
  tooltip.style.display = 'none';
  tooltip.dataset.nodeId = '';
}

// Dismiss tooltip on click outside
canvasArea.addEventListener('click', (e) => {
  if (!e.target.closest('.svg-node') && !e.target.closest('#fc-tooltip')) {
    hideFcTooltip();
  }
});

// Close md-viewer via backdrop click
document.getElementById('md-viewer-backdrop').addEventListener('click', closeMdViewer);

// ── Info Panel ──
document.getElementById('info-panel-backdrop').addEventListener('click', closeInfoPanel);

function openInfoPanel() {
  if (!state.selectedFlowchart) return;
  const p = phases[state.selectedFlowchart];
  const desc = FLOWCHART_DESCS[state.selectedFlowchart];
  const name = p ? p.label : state.selectedFlowchart;
  const cmd = p ? p.cmd : '/' + state.selectedFlowchart;

  document.getElementById('info-panel-title').textContent = name;

  let html = `<div class="info-subtitle">${cmd}</div>`;

  if (desc && typeof desc === 'object') {
    if (desc.summary) html += `<div class="info-summary">${desc.summary}</div>`;
    if (desc.body) html += `<div class="info-desc">${desc.body}</div>`;
    if (desc.meta) {
      html += '<div class="info-meta">';
      if (desc.meta.complexity) html += `<span><strong>Complexity:</strong> ${desc.meta.complexity}</span>`;
      if (desc.meta.output) html += `<span><strong>Output:</strong> <code>${desc.meta.output}</code></span>`;
      if (desc.meta.skill) html += `<span><strong>Skill:</strong> ${desc.meta.skill}</span>`;
      if (desc.meta.discovery) html += `<span><strong>Discovery:</strong> ${desc.meta.discovery}</span>`;
      if (desc.meta.cache) html += `<span><strong>Cache:</strong> ${desc.meta.cache}</span>`;
      html += '</div>';
    }
  } else if (desc) {
    html += `<div class="info-desc">${desc}</div>`;
  } else if (p && p.desc) {
    html += `<div class="info-desc">${p.desc}</div>`;
  }

  if (SOURCE_MAP[state.selectedFlowchart]) {
    html += `<button class="info-panel-source-btn" onclick="openMdViewer('${state.selectedFlowchart}')">&lt;/&gt; View Source</button>`;
  }

  document.getElementById('info-panel-body').innerHTML = html;
  document.getElementById('info-panel').classList.add('open');
  document.getElementById('info-panel-backdrop').classList.add('visible');
}

function closeInfoPanel() {
  document.getElementById('info-panel').classList.remove('open');
  document.getElementById('info-panel-backdrop').classList.remove('visible');
}

function openMdViewerFromZoom() {
  if (!state.selectedFlowchart || !SOURCE_MAP[state.selectedFlowchart]) return;
  openMdViewer(state.selectedFlowchart);
}

function updateContextButtons() {
  const hasFlowchart = !!state.selectedFlowchart;
  const hasSource = hasFlowchart && !!SOURCE_MAP[state.selectedFlowchart];
  const infoBtn = document.getElementById('btn-info');
  const sourceBtn = document.getElementById('btn-source');
  if (infoBtn) {
    infoBtn.classList.toggle('disabled', !hasFlowchart);
  }
  if (sourceBtn) {
    sourceBtn.classList.toggle('disabled', !hasSource);
  }
}

// ── Interaction ──
function highlightNavButtons(phase, clickedBtn) {
  document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
  if (!phase) return;
  if (clickedBtn) {
    // Highlight only the specific button that was clicked
    clickedBtn.classList.add('active');
  } else {
    // Fallback: highlight by ID (for hash navigation, programmatic calls)
    const byId = document.getElementById('btn-' + phase);
    if (byId) byId.classList.add('active');
  }
}

function showOverview() {
  state.view = 'overview';
  state.selectedPhase = null;
  state.selectedFlowchart = null;

  highlightNavButtons(null);
  document.getElementById('btn-overview').classList.add('active');

  hideFcTooltip();
  closeInfoPanel();
  closeMdViewer();
  _layoutCache = {};

  document.getElementById('legend-default').style.display = '';
  document.getElementById('legend-flowchart').style.display = 'none';

  if (isMobile()) closeSidebar();

  if (!_navigatingFromHash) location.hash = 'overview';
  updateContextButtons();

  // Show HTML overview, hide SVG canvas
  canvasArea.classList.add('overview-active');
}

function selectPhase(phase, clickedBtn) {
  if (isMobile()) closeSidebar();
  closeInfoPanel();
  closeMdViewer();
  if (!_navigatingFromHash) location.hash = phase;

  // Hide HTML overview, show SVG canvas
  canvasArea.classList.remove('overview-active');

  // If it has a flowchart, show it
  if (FLOWCHARTS[phase]) {
    state.view = 'flowchart';
    state.selectedFlowchart = phase;
    state.selectedPhase = phase;

    highlightNavButtons(phase, clickedBtn);

    hideFcTooltip();
    _layoutCache = {};

    document.getElementById('legend-default').style.display = 'none';
    document.getElementById('legend-flowchart').style.display = '';

    updateContextButtons();
    resetZoom();
    renderSVG();
    return;
  }

  // No flowchart — just highlight sidebar
  state.selectedPhase = phase;
  state.selectedFlowchart = null;
  highlightNavButtons(phase, clickedBtn);

  updateContextButtons();
  renderSVG();
}

// ── Zoom & Pan ──
let currentScale = 1;
let currentPanX = 0, currentPanY = 0;

function updateTransform() {
  const g = svg.querySelector('g.transform-group');
  if (g) g.setAttribute('transform', `translate(${currentPanX},${currentPanY}) scale(${currentScale})`);
}

function zoom(factor) {
  const vb = svg.getAttribute('viewBox').split(' ').map(Number);
  const newW = vb[2] / factor;
  const newH = vb[3] / factor;
  const cx = vb[0] + vb[2] / 2;
  const cy = vb[1] + vb[3] / 2;
  svg.setAttribute('viewBox', `${cx - newW/2} ${cy - newH/2} ${newW} ${newH}`);
}

function resetZoom() {
  renderSVG();
}

// Mouse wheel zoom
canvasArea.addEventListener('wheel', (e) => {
  if (state.view === 'overview') return;
  if (e.target.closest('.md-viewer') || e.target.closest('.info-panel')) return;
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.03 : 1/1.03;
  zoom(factor);
});

// Pan
let isPanning = false, panStart = { x: 0, y: 0 }, vbStart = [0,0,0,0];
canvasArea.addEventListener('mousedown', (e) => {
  if (state.view === 'overview') return;
  if (e.target.closest('.svg-node') || e.target.closest('.md-viewer') || e.target.closest('.info-panel')) return;
  isPanning = true;
  panStart = { x: e.clientX, y: e.clientY };
  vbStart = svg.getAttribute('viewBox').split(' ').map(Number);
  canvasArea.style.cursor = 'grabbing';
  canvasArea.style.userSelect = 'none';
  e.preventDefault();
});
window.addEventListener('mousemove', (e) => {
  if (!isPanning) return;
  const dx = (e.clientX - panStart.x) * (vbStart[2] / canvasArea.clientWidth);
  const dy = (e.clientY - panStart.y) * (vbStart[3] / canvasArea.clientHeight);
  svg.setAttribute('viewBox', `${vbStart[0] - dx} ${vbStart[1] - dy} ${vbStart[2]} ${vbStart[3]}`);
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  canvasArea.style.cursor = '';
  canvasArea.style.userSelect = '';
});

// ── Touch: single-finger pan + two-finger pinch-to-zoom ──
let touchPanning = false, touchPanStart = { x: 0, y: 0 }, touchVbStart = [0,0,0,0];
let pinching = false, pinchStartDist = 0, pinchVbStart = [0,0,0,0], pinchMid = { x: 0, y: 0 };

function touchDist(t) {
  const dx = t[1].clientX - t[0].clientX;
  const dy = t[1].clientY - t[0].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function touchMidpoint(t) {
  return { x: (t[0].clientX + t[1].clientX) / 2, y: (t[0].clientY + t[1].clientY) / 2 };
}

canvasArea.addEventListener('touchstart', (e) => {
  if (state.view === 'overview') return;
  if (e.target.closest('.zoom-controls') || e.target.closest('.md-viewer') || e.target.closest('.info-panel')) return;
  const t = e.touches;
  if (t.length === 2) {
    // Start pinch
    touchPanning = false;
    pinching = true;
    pinchStartDist = touchDist(t);
    pinchVbStart = svg.getAttribute('viewBox').split(' ').map(Number);
    pinchMid = touchMidpoint(t);
  } else if (t.length === 1 && !e.target.closest('.svg-node')) {
    // Start pan
    touchPanning = true;
    touchPanStart = { x: t[0].clientX, y: t[0].clientY };
    touchVbStart = svg.getAttribute('viewBox').split(' ').map(Number);
  }
}, { passive: true });

canvasArea.addEventListener('touchmove', (e) => {
  if (state.view === 'overview') return;
  if (e.target.closest('.zoom-controls') || e.target.closest('.md-viewer') || e.target.closest('.info-panel')) return;
  e.preventDefault();
  const t = e.touches;
  if (pinching && t.length === 2) {
    const dist = touchDist(t);
    const factor = dist / pinchStartDist;
    const newW = pinchVbStart[2] / factor;
    const newH = pinchVbStart[3] / factor;
    // Zoom toward pinch midpoint
    const svgRect = canvasArea.getBoundingClientRect();
    const mx = pinchMid.x - svgRect.left;
    const my = pinchMid.y - svgRect.top;
    const ratioX = mx / svgRect.width;
    const ratioY = my / svgRect.height;
    const newX = pinchVbStart[0] + (pinchVbStart[2] - newW) * ratioX;
    const newY = pinchVbStart[1] + (pinchVbStart[3] - newH) * ratioY;
    svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
  } else if (touchPanning && t.length === 1) {
    const dx = (t[0].clientX - touchPanStart.x) * (touchVbStart[2] / canvasArea.clientWidth);
    const dy = (t[0].clientY - touchPanStart.y) * (touchVbStart[3] / canvasArea.clientHeight);
    svg.setAttribute('viewBox', `${touchVbStart[0] - dx} ${touchVbStart[1] - dy} ${touchVbStart[2]} ${touchVbStart[3]}`);
  }
}, { passive: false });

canvasArea.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) pinching = false;
  if (e.touches.length < 1) touchPanning = false;
}, { passive: true });

// ── Hash Navigation ──
let _navigatingFromHash = false;

function navigateFromHash() {
  const hash = location.hash.replace('#', '');
  // Skip if we're already viewing this phase (avoids re-highlighting from programmatic hash changes)
  const currentKey = state.selectedFlowchart || state.selectedPhase;
  if (hash && hash === currentKey) return;
  if ((!hash || hash === 'overview') && state.view === 'overview') return;
  _navigatingFromHash = true;
  if (!hash || hash === 'overview') {
    showOverview();
  } else if (phases[hash] || FLOWCHARTS[hash]) {
    selectPhase(hash);
  } else {
    showOverview();
  }
  _navigatingFromHash = false;
}

window.addEventListener('hashchange', navigateFromHash);

// ── Init ──
if (location.hash && location.hash !== '#' && location.hash !== '#overview') {
  navigateFromHash();
} else {
  // Show HTML overview on initial load
  canvasArea.classList.add('overview-active');
  document.getElementById('btn-overview').classList.add('active');
  updateContextButtons();
}
</script>
</body>
</html>
